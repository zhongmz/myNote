# 1引言

## 一些定义

### 数据库系统是什么？

- 由一个互相**关联**的数据的集合和一组用以访问这些数据的**程序**组成。

### 数据库是什么？

- 这个**数据集合**通常称作数据库(database)

### 数据库系统的主要目的是什么？

- 给用户提供数据的抽象视图， 也就是说， 系统隐藏关于数据存储和维护的某些细节。

## 数据库系统的目标

### 文件处理系统中存储组织信息的弊端

#### 数据冗余和不一致（重复，并且不一致）

- data redundancy and inconsistency 

####  数据访问困难（索引困难）

- difficulty in accessing data

#### 数据孤立（不同文件，不同格式）

- data isolation 

#### 完整性问题（难以满足新的约束）

- integrity problem 

#### 原子性问题

- atomicity problem 

#### 并发访问异常（文件互斥访问过于束缚）

- concurrent - access anomaly 

####  安全性问题

- security problem

## 数据视图

### 数据抽象

#### 数据抽象的3个层次是什么

##### physical level 物理层，如何存储

##### logical level 逻辑层，确定数据库中需要存储什么信息

##### view level 视图层，隐藏部分数据，用户所看到的是这些视图

![数据抽象的3个层次](https://i.loli.net/2020/08/26/BtgSU9Zwr6WnIpM.png)





### 实例Instance和模式Schema

#### 什么是实例？

- 数据库的一个实例`instance`是**特定时刻**存储在数据库中的信息的**集合**，相当于值

#### 什么是模式？

- 数据库模式是数据库的总体设计，不发生变化，即使发生变化也不频繁，相当于变量

#### 有几种模式？ 

##### 物理模式【存储】

##### 逻辑模式【应用】

##### 子模式【本质上是视图层的模式】

- 物理模式隐藏在逻辑模式下，并且通常可以在应用程序丝毫不受影响的情况下被轻易地更改

#### 物理数据独立性是什么？

- 应用程序如果不依赖于物理模式，即使物理模式发生改变数据也不需要重写。

### 数据模型

#### 数据模型是什么？

- 数据模型是一个描述**数据**、数据**联系**、数据**语义**以及**一致性约束**的概念工具的集合。

#### 有哪些数据模式？

##### 关系模型

##### 实体关系模型

##### 基于对象的数据模型

##### 半结构化数据模型 (XML)

##### 网状数据模型

##### 层次数据模型

## 数据库语言

### DML 数据操纵语言

#### DML是什么？

- 用户可以访问或操纵那些按照某种适当的数据模型组织起来的数据。

- 检索
- 插入
- 删除
- 修改

#### DML的2种基本分类

##### 过程化 DML

- 要求用户指定需要什么数据以及**如何**获得这些数据。

##### 声明化DML

- 只要求用户指定需要什么数据

### DDL 数据定义语言【数据的数据】

#### 什么是DDL？

- 定义数据的其他特征。

#### 什么是数据存储和定义语言？

- 一种特殊的数据定义语言
- 说明了数据库系统所使用的**存储结构**和**访问方式**

#### 一致性约束有哪些？

##### 域约束【即定义域】

##### 参照完整性【即外键】

##### 断言

- 一个断言就是数据库需要时刻满足的某一条件。

##### 授权【即权限的约束】

###### 读权限

###### 插入权限

###### 更新权限

###### 删除权限

#### 什么是数据字典

- DDL生成的输出放在数据字典中，数据字典中有元数据
- 数据字典可看做是一个特殊表



## 关系数据库

## 数据库设计

### 实体-联系模型【E-R数据模型】

#### ER模型的设计过程

- 现实生活中看的见的可以作为实体集
- 

#### 实体通过什么来描述？

- 属性

#### 联系是什么？

- 联系是几个实体之间的关联

#### 实体集是什么？

- 同一类型的所有实体的集合

#### 联系集是什么？

- 同一类型的所有联系的集合

### 规范化

#### 为什么要规范化？

- 生成一个关系模式集合，使我们存储信息时没有不必要的冗余，同时又能很轻易地检索数据。

## 数据存储和查询

### 存储管理器

#### 存储管理部件有哪些？

##### 权限及完整性管理器

##### 事务管理器

##### 文件管理器

##### 缓冲区管理器

#### 存储管理部件实现了哪些数据结构？

##### 数据文件

##### 数据字典

##### 索引

### 查询处理器

#### 查询处理器组件

##### DDL解释器

##### DDL编译器

##### 查询执行引擎

## 事务管理

### 事务管理器包括什么？

#### 恢复管理器

##### 恢复管理其的职责？

- 原子性
- 持久性

#### 并发控制管理器

- 保证了数据库的一致性



### 客户服务器系统

#### 两层体系结构

- 应用程序在客户机，客户使用查询语句来调用服务器上的数据库系统功能

#### 三层体系结构

- 客户端通过表单界面和应用服务器通信
- 然后应用服务器和数据库系统通信来访问数据

![系统体系结构](https://i.loli.net/2020/08/26/Imyf1hiA8aKCBXD.png)



### 并行数据库系统

#### 分类

##### 粗粒度并行机

##### 细粒度并行机

#### 性能度量方式

##### 吞吐量

##### 响应时间

### 分布式数据库系统

#### 为什么要分布式？

##### 数据共享

##### 自治性

##### 可用性



## 数据库的用户





# 2关系模式介绍

## 关系数据库结构

### 关系【relation】是什么？

- 表示`代表`

### 元组【tuple】是什么？

- 表示【行】

### 属性【attribute】是什么？

- 表示列
- 属性都是原子的

### 域【domain】是什么？

- 一个属性允许取值的集合称之为该属性的域

### 空值【null】是什么？

- 一个特殊的值，表示**未知**或者**不存在**

## 数据库模式

### 模式和实例【schema  and instance】

- 模式是数据库的逻辑设计，实例是给定时刻中数据库数据的一个快照

## 码

### 超码【superkey】是什么？

- 超码是一个能**唯一标识**一个元组的**属性集合**

### 候选码【candidate key】是什么？

- 最小超码【它的任意真子集都无法成为超码】

### 主码【primary key】是什么？

- 代表被数据库设计者所选中的，用来区分不同元组的候选码**候选码**
- 如何挑选：挑选始终不变或者很少发生改变，是为了让DBMS更加方便

### 外码【foreign key】是什么？

- 注意：有**参照关系**才存在外码的概念
- 若一个关系模式$r_1$在它的属性中包括另外一个关系模式$r_2$的**主码**，这个属性在$r_1$上称作**参照**$r_2$的外码

### 参照关系【referencing relation】是什么？

- 关系$r_1$称为外码依赖的参照关系

### 参照完整性【integrity】约束是什么？

- 在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值。



## 模式图

- 注意和E-R图不是一个东西

- 没有**显性**表示出参照完整性约束

- 长这个样子

  ![屏幕截图 2020-10-31 114333](https://i.loli.net/2020/10/31/lY2njcukB9QCTSM.png)

## 关系查询语言

- 定义了一组运算集，以表为输入，返回一个表

## 关系运算

- 提供了一组运算，以一个或多个关系为输入，返回一个关系





# 3SQL

### SQL是什么？

- SQL是一种数据库查询语言
- 本篇所描述的SQL特征是SQL-92

### SQL包括几个部分？

#### 数据定义语言

#### 数据操纵语言

#### 完整性

#### 视图定义

#### 事务控制

#### 嵌入式SQL和动态SQL

#### 授权

## SQL数据定义

### 基本类型

##### char(n)  固定长度的字符串，用户指定长度n

##### varchar(n)   可变长度的字符串，用户指定最大长度n

##### int   整数

##### smallint  小整数

##### numeric(p,d)    定点数  

- p位数字
- d位数字在小数点右边
- 1位符号位

##### real,double precision   浮点数和双精度浮点数

##### float(n)   精度至少为n位的浮点数

### 基本模式定义

#### 定义SQL关系【create table】

```sql
create table department
	(dept_name varchar(20),
	building varchar(15),
	budget numeric(12,2),
	primary key(dept_name));primary key 自带not null
```

##### 有哪些完整性约束？

###### primary key

```
eg primary key(dept_name,building)
```

###### foreign key

```sql
eg foreign key(course_id,sec_id) references section
```

###### not null 

```sql
eg name varchar(20) not null,
```

#### 删除元组【delete 】

- 注意是**元组**

##### 删除所有元组

```sql
delete from r;
```

#### 删除关系【drop】

```sql
drop table r
```

##### 增加属性【alter 】

```sql
alter table r add A D;
```

- 其中r是现在关系的名字
- A是添加属性的名字
- D是添加属性的域

## SQL查询【select】的基本结构

- 由子句`select from where `构成

### 单关系查询

#### 【distinct】在select 中去重

```sql
select distinct dept_name
from instructor;
```

#### 【all】在select 中 查询所有（即不去重）

```sql
select all dept_name
from instructor;
```



#### select 子句可进行算术运算

```sql
select distinct dept_name,salary * 1.1
from instructor;
```

#### where

- 选出那些在from的关系中满足特定谓词的元组

##### eg

- 找出所有在Comp.Sci.中且工资超过70000美元的教师的姓名

```sql
select name
from instructor
where dept_name = "Comp.Sci." and salary > 70000;
```

### 多关系查询

#### eg  多表查询

- #### ＂ 找出所有教师的姓名，以及他们所在系的名称和系所在建筑的名称＂ 

```sql
select name ,department.dept_name ,building
from INSTRUCTOR,department
where INSTRUCTOR.DEPT_NAME = department.dept_name;
```

- from r1,r2可以看做是做笛卡尔乘积【但是实际并不是】

#### 思考的顺序

1. from 子句中列出关系产生的**笛卡尔积**
2. where  子句 使用谓词
3. select  子句输出指定的属性

#### from的本质

- 定义了该子句列出关系的笛卡尔积
- 即使由相同的属性也认为是不同的属性，department.dept_name 和instructor.dept_name 认为是不同的属性

```python
for each t1 in r1
	for each t2 in r2
		把 t1 t2 连接成 t
		把t加入关系中
```

### 自然连接

#### 自然连接是什么?

- 自然连接只考虑哪些在2个关系模式上都出现**所有**属性**取值相同**的元组对

##### eg 找出大学中所有讲授课程的教师，找出他们的姓名和所讲课程的标识

```sql
select name ,course_id
from instructor natural join teaches
```

```sql
select name,course_id
from instructor,teaches
where instructor.id = teaches.id
```

- 上述2者效果相同

#### r1 join r2 using (A1,A2...)

##### eg 查询“列出教师名字和它们讲授课程的名称”

```sql
select name,title
from instructor natural join teaches,course
where teaches.course_id = course.course_id;
```

```sql
select name,title
from (instructor natural join teaches ) join course using (course_id);
```

- 上述结果相同

- **注意！**

- ```sql
  select name ,title
  from instructor natural join teaches natural join course;
  ```

- 这个并不是查询出想要的，因为需要dept_name和course_id相同才能连接。因为该查询会忽略所有这样的对：教师所讲授的课程不是他所在的系的课程





## 附加的基本运算

### 更名运算【as】

```sql
old-name as new-name
```

- 在select出现时，只是修改属性名字，在where中不使用【可以从select的执行顺序来理解】
- from 子句中出现，可用于where子句

#### 更名和子查询

```sql
create Table test
(
    Id int primary key ,
    Name varchar(10),
    Salary int,
    ManagerId int references test(Id)
);
select E1.Name
from test  E1 ,test  E2
where E1.Salary > (
    select E2.Salary
    from E2
    where E1.ManagerId = E2.Id
);
```

- 对于这样的查询是错误的，因为更名运算后的名字仅对于当前查询有效，作用域不包括其子查询

#### eg

```sql
select name as instructor_name,course_id
from instructor,teaches
where instructor.id=teaches.id
```

```sql
select T.name,S.course_id
from instructor as T,teaches as S
where T.id = S.id
```

#### 为什么要更名？

- 方便查询，打字更少

- 为了适用于需要**比较**同一个关系中的元组

- eg 查询”找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高”

  ```sql
  select distinct T.name
  from instructor as T,instructor as S
  where T.salary > S.salary and S.dept_name ="Biology";
  ```

#### 什么是【相关名称】【表别名】【相关变量】【元组变量】

- 上面4个都是一个意思，被用来重命名关系的标识，比如上述的T



### 字符串运算

- 单引号来标识字符串
- 若单引号是字符串的组成之一，则使用双引号来表示 【 "it 's right'"】

### SQL大小写敏感吗？

- 在SQL标准中是敏感的

#### 大小写转换函数

```sql
 select lower(ename) from emp;
 select upper(ename) from emp;
```



#### like 操作符实现模式匹配

##### %：匹配任意字符串

##### _ ：匹配任意一个字符

##### eg 

- ‘Intro%' 匹配任意以'Intro'开头的字符串
- '% Comp%' 匹配含有Comp的字符串
- '___' 匹配3个字符的字符串
- '___%'匹配至少有3个字符的字符串

- 找出所在建筑名称中包含子串'Watson'的所有系名“ ，该查询的写法如下：

  ```sql
  select dept_name
  from department
  where building like '%Watson%';
  ```



### order by A 排列元组的显示次序

- 默认是升序
- order by A desc 表示降序【descend】
- order by B asc 表示升序【ascend】
- 也能够在多个属性上进行

#### eg 1

- 查询“按字母顺序列出在Physics系的所有教师”

- 

  ```sql
  select name 
  from instructor
  where dept_name = 'Physics'
  order by name;
  ```

#### eg2

```sql
select * 
from instructor
order by salary desc, name asc;
```



### where 子句

#### between

```sql
where salary between 90000 and 100000;
where salary <= 100000 and salary >= 90000;
```

- 上述2者相同

### not between 

- 效果和between 相反

### 多维判等

```sql
where instructor.id = teaches.id and dpet_name = "A";
where (instructor.id,dept_name) = (teaches.id,"A");
```

- 上述2者相同

## 集合运算

- 无论是哪一个都是对2个**相同属性**集合【表】进行运算

### union并运算

- union运算自动去重

#### eg 

- 找出在2009年秋季开课， 或者在201 0年春季开课或两个学期都开课的所有课程

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
union
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

- 若期望保留重复

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
union all
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

### intersect 交运算

#### eg

- 找出在2009年秋季和2010年春季同时开课的所有课程的集合

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
intersect 
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

### except 差运算

#### eg

- 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
except
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

## 空值

### 空值作为算术表达式输入

- 若算术表达式的输入为为空，其输出为空

### 空值作为逻辑表达式的输入

- 输出可以为如下值
  - true
  - false
  - unknown

### 注意！

```sql
('A',null) 和('A',null)这2个元组被认为是相同的
但是在谓词中，null = null 这个谓词公式会返回unknown，而不是true 
```

## 聚集函数

#### 什么是聚集函数？

- 聚集函数是以值的一个集合（集或多重集）为输人、返回**单个值**的函数

#### SQL中有哪些聚集函数？

##### avg  平均值

##### min  最小值

##### max  最大值

##### sum  总和

##### count  计数



### 基本聚集

#### eg 删除重复元组＋聚集函数

- 找出在2 010年春季学期讲授一门课程的教师总数【这里可能会有语义冲突，其意思是表达“在2 010年春季学期讲授课程的教师【不重复计数】】

- ```sql
  select count(distinct id)
  from teaches
  where semester = "Spring" and year = 2010
  ```

#### 注意！

- SQL不允许在`count(*)`中使用distinct，虽然从语义上来思考，使用了和没有使用是没有区别的

### group by 分组聚集

- group by子句中给出的一个或多个属性是用来构造分组的。在group by子句中的**所有属性上取值相同**的元组将被分在一个组中。
- 当没有group by的时候可以看做是一个组 

#### eg1

- 找出每一个系的平均工资

```sql
select dept_name avg(salary) as avg_salary
from instructor
group by dept_name;
```

#### eg2

- 考虑查询＂ 找出每个系在2010年春季学期讲授一门课程的教师人数”
- 关键词： 系 2010  春季学期  去重 人数【count】

```sql
select DEPT_NAME ,COUNT (DISTINCT ID)  AS INST_COUNT
from instructor natural join teaches 
where semester = 'Spring' and year = '2010'
group by dept_name;
```

#### 注意！

- select中的属性要么出现在group 中要么出现在聚集函数中。

### having子句

- having 对于 group by 相当于 where 对于from
- 即对于group by的元组进行**筛选**，**符合条件的才能被select**

#### eg

- 查询教师平均工资超过42 000美元的系

  ```sql
  select dept_name avg(salary) as avg_salary
  from instructor
  group by dept_name
  having avg(salary) >42000;
  ```

#### 超级注意！

1. from 【得到一个关系】
2. where   【是一个条件，满足条件的才能被select 或者是group up】
3. group up 假设没有group up 那么当成一组【有group up那么就说明必然有聚集函数】
4. having 对那些聚集函数和group up 中的属性进行筛选
5. select 

### 对空值和布尔值的聚集

- 除了`count(*)`外所有的聚集函数都**忽略**输入集合中的空值
- 规定空集的count运算值为0, 其他所有聚集运算在输入为空集的情况下返回一个空值。



## 嵌套子查询

### 集合成员资格 in not in

#### in测试元组是否是集合中的成员

##### eg

- ＂ 找出在2009年秋季和2010年春季学期同时开课的所有课程” 。

```sql
select distinct course_id
from section
where semester ="Spring " and year ='2010' and course_id in(
 	select distinct course_id
    from section
    where semester ="Fall" and year= "2009"
);
```

#### not in

- 和in类似

#### in 和 not in都能作用于枚举类型【从其定义也可以看出】

- 找出name不是A也不是B的人

```sql
select distinct name
from instructor
where name not in ('A','B');
```

### 集合的比较 some all

#### some

##### eg

- 找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高＂

```sql
select name
from instructor
where salary > some (
	select salary
	from instructor
	where dept_name = "Biology"
);
```

- = some 等价于in
- <>some不等价于 not in



#### all

- <>all 等价于 not in
- =all 不等价于 in



### 空关系测试exists and not exists

- 这个使用的时候，一般都会有换名操作的出现

- exists作为谓词查询是否为空 若非空则返回true'
- not exists 反之

#### eg

- 找出在2009年秋季学期和2010年春季学期同时开课的所有课程

```sql
select course_id
from section as S
where semester = "Fall" and year = 2009 and exists(
		select *
		from section as T
		where semester = "Spring" and year =2010 and S.course_id  =T.course_id
	);
```

#### 什么是相关子查询?

- **相关**
- 使用了来自外层查询相关属性的子查询称作相关子查询
- 比如该节的eg

#### not exists

##### 谓词“关系A包含关系B”

- 可以理解为集合A包含集合B【元素为相同属性的值】

- ```sql
  not exists (B except A)
  ```



##### eg

- 【问题】找出选修了Biology 开设的所有课程的学生

- 【分析】 

  - 有哪些表？course表 takes 表 学生表student
  - 有哪些函数依赖？ takes 中的id依赖student的id ；takes 中的course_id间接依赖course
  - 按顺序分析 写语句

- 【写语句】

  ```sql
  select student.id 
  from  student
  where not exists(
  	(select course_id
      from  course
      where dept_name = 'Biology')
      except
     	(select takes.course_id
      from takes
      where takes.id = student.id)
  
  );
  ```

### 重复元组存在性测试unique

- 测试一个子查询的结果中是否存在重复元组
- 若只有一个元组则返回true

#### eg

- 找出所有在2009年最多开设一次的课程

- 涉及到2009那么一定存在section这个表

- ```sql
  select course.course_id
  from course  --思考哪一个表
  where unique(--再思考表的约束
  	select section.course_id
  	from section
  	where course.course_id = section.course_id
  	and section.year = 2009
  );
  ```

- 使用 **聚集函数**+ 逻辑运算符

- ```sql
  select course.course.id
  from course 
  where 1 > = (
  	select count(*)
    from section
      where section.course_id = course.course_id and section.year = 2009
  );
  ```
  

#### not unique

- 找出所有2009 年最少开设2次的课程

- ```sql
  select course.course_id
  from course  --思考哪一个表
  where not unique(--再思考表的约束
  	select section.course_id
  	from section
  	where course.course_id = section.course_id
  	and section.year = 2009
  );
  ```

### from 子句中的子查询

#### eg

- 找出系平均工资超过42 000美元的那些系中教师的平均工资

- 分析：只需要instructor这个表就可以得到答案，分两步：1，得到平均工资，2，得到满足条件的平均工资

- ```sql
  select dept_name ,avg_salary
  from (
  	select dept_name ,avg(salary) as avg_salary
      from instructor
      group by dept_name
  )
  where avg_salary >42000
  ```

- **注意**：Oracle允许对子查询结果进行重命名，也支持对表的重命名，但是不允许对关系中的**属性**进行重命名

#### 表的更名

```sql
(   ) as new_table_name(A1,A2,A3...);
```



#### eg

- 找出所有系中工资总额最大的系

- ```sql
  select max(tot_salary)
  from (
  	(select dept_name,sum(salary)
      from instructor
      group by dept_name) as dept_total(dept_name,tot_salary)
  );
  ```



### with 子句

#### 什么是with子句？

- with子句提供定义**临时关系**的方法，只对含with子句的查询有效【即 本查询】

- ```sql
  with new_table_name(A1,..) as(
  	select something
  	from sometable
      where some_condition
  )--在下一次select可以使用
  select 
  from 
  where
  ```

  

#### eg1

- 找出具有最大预算值的系

```sql
with max_budget(value)as(
	select max(budget)
    from department
)
select budget
from department,max_budget
where department.budget = max_budget.value;
```



#### eg2

- 我们要查出所有工资总额大于所有系平均工资总额的系
- 这里需要工资总额表，工资平均总额表

```sql
with 
dept_total(dept_name,value) as
(
	select dept_name,sum(salary) 
    from instructor
    group by dept_name
),--这个表可以给下一个表用
dept_total_avg(value)as
(
    select avg(value)
    from dept_total
)--上面2个表可以给接下来的正式查询使用
select dept_name
from dept_total,dept_total_avg
where dept_total.value >= dept_total_avg.value;
```



### 标量子查询

#### 什么是标量子查询？

- 一个子查询若它只返回包含**单个属性**的**单个元组**，那么这个子查询称为**标量子查询**
- **注意**，虽然其结果只有单个元组，但是它还是关系

#### eg

- 列出所有的系以及它们拥有的教师数

- `instructor`和`department`

- ```sql
  select dept_name,
  (
  	select count(*)
  	from instructor
      where instructor.dept_name = department.dept_name
  )
  from department;
  ```



## 数据库的修改

### 删除

- 和查询类似

### 插入

#### eg

- 假设我们想要插人的信息是Computer Science系开设的名为"Database Systems"的课程CS-437, 它有4个学分。我们可写成

- ```sql
  insert into course 
  	values(('CS-437','Database Systems','Comp. Sci.', 4);
  ```

- ```sql
  insert into course (course_id,title,dept_name,credits}
  values ('CS -437','Database Systems','Comp. Sci.', 4) ;
          
  insert into course (title,course_id, credits, dept_name}
  values ('Database Systems','CS -437', 4,'Comp. Sci.') ;
  ```

### 更新

#### eg

- 假设要进行年度工资增长，所有教师的工资将增长5%。我们写出：

- ```sql
  update instructor
  set salary = salary *1.05
  ```



- 只给那些工资低千70 000美元的教师涨工资

- ```sql
  update instructor
  set salary = salary*1.05
  where salary<70000;
  ```



- 请求“对工资低于平均数的教师涨5%的工资”

- ```sql
  update instructor
  set salary = salary*1.05
  where salary<(
  	select avg(salary)
      from instructor
  );
  ```



- 在假设给工资超过100 000 美元的教师涨3%的工资， 其余教师涨5%。我们可以写两条update语句

- ```sql
  update instructor
  set salary =salary *1.03
  where salary>100000;
  update instructor
  set salary =salary *1.05
  where salary<=100000;
  
  ```

- 注意不要颠倒过来哦

#### case语句

```sql
case 
	when 条件 then 结果
end
```



##### eg

- 在假设给工资超过100 000 美元的教师涨3%的工资， 其余教师涨5%。

- ```sql
  update instructor
  set salary = case
  	when salary >100000 then salary*1.03
  	when salary <=100000 then salary *1.05
  	end;
  
  ```

  





# 4中级SQL

## 连接表达式

### 连接条件【on】

```sql
select *
from  R1 join R2 on [设置通用的谓词]
where 
```



#### eg

- 1

```sql
select *
from student join takes on takes.id = student.id;
--等价于
select *
from student,takes
where student.id= takes.id;
```

- 2

  ```sql
  select *
  from student natural join takes
  ```

- 1和2的区别在于：在1中ID属性出现2次，2中只出现1次

#### 为什么引入on条件？

- 在外连接来说，on条件和where条件是不同的
- 使得SQL查询更加容易懂

### 外连接

- 本质上是`自然连接Pro`

#### 自然连接的哪些缺陷导致了外连接的出现？

- 在参与连接的任何一个或两个关系中的某些元组可能会以这种方式” 丢失＂
- 比如`student natural join takes`中没有选修如何课程的学生将会丢失

#### 3种外连接

##### 左外连接(left outer join)

- 只**保留**出现在左外连接运算之前（**左边**）的关系中的元组。

- ```sql
  select*
  from student natural left outer join takes ;
  ```

  

##### 右外连接(right outer join)

-  只**保留**出现在右外连接运算之后（**右边**）的关系中的元组。

##### 全外连接(full outer join)

- 保留出现在两个关系中的元组。

#### 什么是内连接？

- 不保留**未匹配**元组的连接运算称未内连接，比如自然连接

#### eg

- 找出所有一门课程也没有选修的学生

- ```sql
  select id
  from student natural left outer join takes
  where course_id is null;--注意这里不要写course_id =null，这个谓词返回的是unknown 但是前者返回的是true
  --或者写成
  select id
  from takes natural right outer join student
  where course_id is null
  ```



- **全外连接**的例子：考虑查询： “显示Comp.Sci. 系所有学生以及他们在2009年春季选修的所有课程段的列表。2009年春季开设的所有课程段都必须显示， 即使没有Comp.Sci. 系的学生选修这些课程段＂。

- ```sql
  select *
  from (
  	select *
      from student
      where dept_name = "Comp.Sci"
  ) natural full outer join (
      select *
      from takes
      where semester ="Spring" and year =2009
  );
  ```



## 视图

### 视图定义

```sql
create view v as < query expression > ;
```

- 一个视图可能被用到**定义另外一个视图的表达式中**

### 物化视图

#### 什么是物化视图？

- 如果用于定义视图的实际关系改变， 视图也跟着修改。这样的视图被称为**物化视图**

#### 什么是物化视图维护？

- 保持物化视图一直在最新状态的**过程**

### 视图更新

#### 对视图插入的时候对应的关系如何插入？

- 一般**不允许**对视图关系【本质上是虚关系】进行修改

- 若有这样的插入，对视图插入

  ```sql
  insert into faculty
  values ('30765','Green','Music');
  ```

- 有2种处理方法
  - 拒绝插入
  - 插入`('30765','Green','Music',null)`

#### 什么样的视图是可更新的？

满足以下**所有**条件

- from子句中**只有一个数据库关系**。
- select子句中**只包含关系的属性名**，不包含任何表达式、聚集或distinct声明。
- 任何**没有出现**在select子句中的属性**可以取空值**；【即，这些属性上没有not null约束，也不构成主码的一部分】。
-  查询中**不含有group by或having**子句。

## 事务

### 结束一个事务的SQL语句

- `Commit work`: 提交当前事务
- `Rollback work`：回滚当前事务

## 完整性约束

### 完整性约束的目的是什么？

- 保证授权用户对数据库所做的修改**不会破坏数据的一致性**

### 单个关系上的约束

#### not null

```sql
name varchar(20) not null
```

#### unique

```sql
unique(A,B,C...)
```

- 那么`(A,B,C..)`构成了候选码
- 唯一属性**可以为null**, 除非它们已被显式地声明为not null。

#### check<谓词>

```sql
check (semester in ('Fall','Winter','Spring','Swnmer'))
```

### 参照完整性

```sql
foreign key( dept—name) references department
```

#### 外键的选择有哪些？

- 外键必须被声明为被参照关系的一个候选码【即：要么有primary key 约束，要么有unique 约束】

#### 当删除操作或者更新操作违反了参照完整性应该如何处理？

- 拒绝执行

- 级联删除，级联更新cascade

  - ```sql
    create table course
    (	--.....
    	foreign key (dept_name) references department on delete cascade on update cascade,--其中cascade的意思是级联
        --.....
    );
    ```



#### 一个约束可以被指定为可延迟的

##### 为什么需要延迟检查约束？

- 有这样的一个例子，假设我们有一个主码为name 的person 关系， 还有一个属性是spouse,并且是person关系中的一个外码
- 我们想插入(john,mary)这一对伴侣，但是若采用立即检查约束，则会导致永远也插不进去【类似死锁】

## 断言【多表check约束】

### 断言和check的区别在哪里？【什么时候使用断言？】

- 断言一定是多个关系的约束，check只能是一个关系的约束

### assertion断言如何写？

```sql
create assertion assertion-name check (
	predicate--这里写一些谓词啥的,
)
```

### 什么时候检查断言？

- 每一次更新都会检查！！
- 所以要谨慎使用啊

### eg

- 有这样的一个约束：对于student关系中的每个元组， 它在属性tot_cred上的取值必须等于该生所成功修完课程的学分总和。

- ```sql
  create assertion credits_earned_constraint check(
  	not exists(
      	select ID
          from student
          where tot_cred <> (
          	select sum(credits)
              from takes natural join course
              where student.ID = takes.ID and grade is not null and grade <> 'F'
         	)
      )
  );
  ```

  



## 授权grant

### 有哪些权限？

```
select
insert
update 
delete
all privieges
```

- 但是需要注意的是all privieges并不等价于select,insert,update,delete相加

### 基本形式

```sql
grant <权限列表>
on <关系名或者视图名>
to <用户/角色列表> --其中public表示所有用户
```



### revoke收回权限

```sql
revoke <权限列表>
on <关系名或者视图名>
from <用户/角色列表> --其中public表示所有用户
```



## 角色role

- role可以被授予权限
- role可以授予给role和user

### 创建角色

```sql
create role instructor;
```

### 授予权限给角色

```sql
grant dean to instructor;
```

### 授予角色给用户

```sql
grant insructor to Tom;
```



## 嵌入式SQL

### 游标cursor

#### 基本形式

##### 定义游标

- 此时还没有分配内存空间

```sql
EXEC SQL
declare c-name cursor for(
	select --
	from --
    where --
)
for update--这里在后面会解释
END_EXEC
```

##### 打开游标

- 当我们open游标的时候，才会给数据分配内存空间

```sql
EXEC SQL
	open c-name
END_EXEC
```

###### 使用游标

- 执行fetch的时候有2个操作
  1. 把当前c所指向的行的每一个列的值分别赋值给c1,c2...
  2. 游标指向下一行【但是此时内存也没有释放】

```sql
EXEC SQL
	fetch c into: c1,c2
END_EXEC
```

##### 关闭游标

- 此时内存才释放

```
EXEC SQL
	close c 
END_EXEC
```

##### 通过游标更新关系中的数据

- 但是此时需要定义游标的时候有for update关键字

```sql
update account
set balance = balance +10
where current of c-name;
```

## 函数和过程



# 6形式化关系查询语言

## 关系代数

### 什么是关系代数？

- 是一种过程化查询语言，包括一个**运算的集合**

### 关系代数的基本运算有6种？

- 选择
- 投影
- 并集合
- 差集合
- 笛卡尔积
- 更名

#### 选择【一元】相当于SQL中的where而不是select

##### eg

- 选择关系instructor属于物理系的那些元组，写作

- ![image-20201118151519372](https://i.loli.net/2020/11/18/3fHeFNQXomIZ6MV.png)



- 查询工资额大于90000美元的所有元组
- ![image-20201118151632780](C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201118151632780.png)



- 为了找到物理系中工资额大千90000美元的教师
- ![image-20201118151713766](C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201118151713766.png)



- 【选择谓词中有2个属性的比较】找出那些系名与楼名相同的系
- ![image-20201118151747055](C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201118151747055.png)

##### 关系代数中的select和SQL的关键词select区别

- 在关系代数中，术语select对应于我们在SQL中使用的where【历史原因】

#### 投影

##### 投影使用什么来表示？

- 投影用大写希腊字母Pi $\Pi$ 表示
- 我们希望出现的**属性**作为$\Pi$的**下标**，**关系**在括号中

##### eg

- 列出所有教师的ID 、name 和salary
- ![image-20201118152228459](C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201118152228459.png)

#### 关系运算的组合

##### eg

- 找出物理系的所有教师的名字
- ![image-20201118152328128](C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201118152328128.png)

##### 什么是关系代数表达式？

- 多个关系代数运算的组合

#### 并运算$\cup$

##### eg

- 找出开设在2009 年秋季学期或者2010 年春季学期或者这二者皆开的所有课程的集合。

- $$
  \Pi_{course\_id}(\sigma_{semster = "Fall" \land year = 2009}(section) )\cup \Pi _{course\_id} (\sigma_{semster ="Spring" \land year =2010}(section))\\
  $$

##### $r\cup s$有意义的条件是什么？【以下条件要同时成立】

- r和s必须同元，并且属性数目必须相同
- 对应的属性的域也要相同

#### 集合差-

##### 什么是集合差？

- 表达式r-s的结果是包含在r中而不在s中的那些关系

##### eg

- 找出所有开设在2009 年秋季学期但是在2010 年春季学期不开的课程

- $$
  \Pi_{course\_id}(\sigma_{semester ="Fall"\land year =2009}(section))-\Pi _{course\_id} (\sigma_{semster ="Spring" \land year =2010}(section))\\
  $$

##### r-s的条件是什么？

- 和$r\cup s$相同

#### 笛卡儿积运算



##### eg

- 希望找出物理系的所有教师， 以及他们教授的所有课程
- ![image-20201118154435301](C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201118154435301.png)

#### 更名$rho (\rho)$

##### eg

- 返回表达式E的结果，并且把名字x赋予它

- 
  $$
  \rho_x(E)\\
  $$

- 返回表达式E的结果， 并赋给它名字x, 同时将各属性更名为A1, A2, …, An

- $$
  \rho_{x(A_1,A_2...A_n)}(E)\\
  $$

- **找出大学里的最高工资**

  - 先查询非最高工资【思考 为什么不能直接查询最高工资：因为没有聚集函数max】

  - $$
    \Pi_{instructor.salary}(\sigma_{instructor.salry< d.salary}(instructor \ *\ \rho_d(instructor) ))
    $$

    

  - 再使用差集来得到最高工资

  - $$
    \Pi_{instructor.salary}(instructor)-\Pi_{instructor.salary}(\sigma_{instructor.salry< d.salary}(instructor \ *\ \rho_d(instructor) ))\\
    $$



### 附加的关系代数运算

#### 集合交运算$\cap$

##### eg

- 找出在2009年秋季和2010年春季都开设的课程

- $$
  \Pi_{course\_id}(\sigma_{semester="Fall" \land year =2009})\cap \Pi_{course_id}(\sigma_{semester ="Spring" \land year=2010})\\
  $$



- 可以使用下列运算来重写集合交运算

- $$
  r\cap s= r-(r-s)
  $$

  



#### 自然连接运算

##### eg

- 找出所有教师的姓名，连同他们教的所有课程的course_id

$$
\Pi_{name,course\_id}(instructor\bowtie teaches)
$$

- 找出计算机系(Comp. Sci.)的所有教师， 以及他们教授的所有课程的名称

- $$
  \Pi _{name,title}(\sigma _{dept_name="Comp.Sci"}(instructor \bowtie teaches \bowtie course))\\
  (instructor\bowtie teaches)\bowtie course 等价于 instructor\bowtie (teaches \bowtie course)\\
  所以可以称自然连接是可结合的
  $$



#### 除法运算

- r / s

- ```
  r中满足s的所有的元组的R-S前缀
  ```

- eg：找出选了教师所有课程的学生





#### 赋值运算$\leftarrow$

$$
temp \leftarrow R*S
$$



#### 外连接运算

- 左外连接：左边的元组都要出现在连接后的关系中
- ![image-20201202105406717](https://i.loli.net/2020/12/02/5yX3uVh4vfcAZax.png)



#### 广义投影【在属性中可以使用代数运算】

$$
\Pi_{F_1...F_n}(E)\\
$$

- 其中F可以使用代数运算

##### eg

$$
\Pi_{ID,name,salary/2}(instructor)\\
$$

#### 聚集函数

##### eg

- 找出所有教师的工资总和
- ![image-20201118202953260](https://i.loli.net/2020/11/18/ZrHpvRFlcWT49jw.png)



- 去重示例
- 找出在2010年春季学期教课的教师数
- ![image-20201118203037562](https://i.loli.net/2020/11/18/8nBlF4Jqv1ux9Kg.png)



- group by的使用
- 求出每个系的平均工资
- ![image-20201118203116616](https://i.loli.net/2020/11/18/SZYKAfcPuNkjv81.png)



#### 删除操作

- 使用赋值操作加上减法

#### 插入

- 使用赋值加上并



### SQL和关系代数

- SQL

- ```sql
  select A1,A2,sum(A3)
  from r1,r2,r3...rn
  where P
  group by A1,A2
  ```

- 等价于的关系代数

- $$
  _{A_1,A_2}G_{sum(A_3)} as \ su\_ a(\Pi _{A_1,A_2...A_n}(\sigma_P(r_1*r_2..r_n)))
  $$

- A表示按什么分组




## 元组关系演算

- 关系代数产生的查询结果是过程化的
- 元组关系演算是**非过程化**的

### 查询表达式

```
{t|P(t)}
```

- 是所有使得谓词P为真的**元组t的集合**
- 使用**t[A]**表示元组t在属性A上的值
- 使用**$t\in r$**表示元组t在关系r中

### 查询示例

#### 如何表示某些属性的查询呢？

$$
\exist t\in r(Q(t))
$$

- 表示**关系r中存在元组t使得谓词Q(t)为真**

#### eg1

- 找出所有工资在80000美元以 上的教师的ID、name、detp _name和salary

- 

- 

- $$
  \{ t| t\in instructor\land t[salary]>80000\}
  $$

#### eg2

- 找出工资大千80 000美元的所有教师的ID

- $$
  \{t|\exist s\in instructor(s[ID]=t[ID]\land s[salary]>80000\}
  $$

  

#### eg3【使用2个$\exist$子句】

- 查询＂找出位置在Watson楼的系中的所有教师姓名＂

- $$
  \{ t|\exist s\in instructor(s[ID]=t[ID]\land \exist u\in department( u[dept\_name]=s[dept\_name]\land u[dept\_name]="Watson")
  )
  \}
  $$



#### 关系代数中的并运算在元组关系演算中是什么？

- **OR$\lor$**连接2个存在子句

##### eg【or，这里自动去重了，因为集合中不能由重复的成员】

- 找出在2009年秋季学期或者2010年春季学期或者这两个学期都开设的所有课程的集合

- $$
  \{\\
  t|\\
  \exist s\in section(t[course\_id ] = s[course\_id]\land s[semester]="Fall"\land s[year]=2009)\\
  \lor\\
  \exist s\in section(t[course\_id]=s[course\_id]\land s[semester]="Spring"\land s[year]=2010)
  \\\}
  $$

- 

##### eg【取反】

- 找出2009年秋季学期开设而2010年春季学期不开的所有课程

- $$
  \{\\
  t|\\
  \exist s\in section(t[course\_id ] = s[course\_id]\land s[semester]="Fall"\land s[year]=2009)\\
  \land\\
  \neg \exist s\in section(t[course\_id]=s[course\_id]\land s[semester]="Spring"\land s[year]=2010)
  \\\}
  $$

##### eg【蕴含】和“对所有”$\forall$

- 找出所有那些选了生物(Biology) 系全部课程的学生

- $$
  \{\\
  t|\\
  \exist r\in student(r[ID] =t[ID])\\
  \land\\
  \forall u\in course(u[dept\_name]="Biology"\Rightarrow\exist s\in takes(t[ID]=s[ID]\land s[course\_id]=u[course\_id]))
  \\\}
  $$



### 对元组关系演算的形式化定义

#### 什么是自由变量？

- 如果元组变量不被$\exist$或$\forall$修饰，则称为自由变量。

#### 原子的定义

- ![image-20201119151245977](https://i.loli.net/2020/11/19/9ByRLcE6kGpPQmo.png)



### 元组的安全性

#### 什么是P的域？

- P的域是P所**引用**的所有值的集合【使用dom(P)来表示】

####  什么样的表达式是安全的？

- 如果出现在表达式**{t|P(t)}**结果中的所有值均来自**dom(P)**,则我们说表达式**{t|P(t)}**是安全的。
  - 表达式$\{t|\neg t\in instructor\}$不安全

### 语言表达能力

- 没有任何一个元组关系演算等价千聚集运算



## 域关系演算

### 域关系演算的形式化定义

- 一般待查询的域都不会在$\exist和\forall$中出现。

$$
\{ <x_1,x_2...x_n>|P(x_1,x_2,...x_n)\}
$$

### eg

![image-20201119152837641](https://i.loli.net/2020/11/19/CPEvLWVx9peowTR.png)

![image-20201119152910654](https://i.loli.net/2020/11/19/eptP5rITVYkzys4.png)



## EG

### 1

- Find all instructors earning the highest salary

- $$
  instructor \bowtie G_{max(salary)\ as \ salary}(instructor)
  $$

- 



### 2

- R=(A,B,C) S = (D, E, F) 关系r(R)和s(S)已给出。请给出与下列每个表达式等价的元组关系演算表达式：
  
  - 表示$r*s$

  - $$
  \{t|\exist p\in r,\exist q \in s   (
    t[A]=p[A]\land 
    t[B]=p[B]\land 
    t[C]=p[C]\land 
    t[D]=q[D]\land 
    t[E]=q[E]\land  
    t[F]=q[F])            \}
    $$



### 3

- 写出$\Pi _{A,B}(r_1)\bowtie\Pi_{B,C}(r_2)$的域关系演算表达式，其中$r_1$和$r_2$都是模式R上的关系

- $$
  \{
  <a,b,c>|\exist p ,\exist q
  (<a,b,p>\in r_1\land <q,b,c> \in r_2)
  \}
  $$

  

# 7数据库设计和E-R模型

## 设计过程



- 定义实体集：
- 定义联系集：
- 定义联系集的度
- 确定实体集的属性





## 实体-联系集

### 实体集

#### 什么是实体？

- 区别于其他对象的对象【比如Xxgzbd】

#### 什么是实体集？

- 具有相同属性的实体的集合【比如person 在设计中记得需要多个实体才能构成实体集】

#### 什么是联系集？

- 相同类型联系的集合【其至少有2个属性】

#### 什么是联系集的度？

- 度是参与联系集的**实体集的数目**

### 属性

#### 属性的划分

##### 简单属性和复合属性

##### 单值属性和多值属性

##### 派生属性【派生属性的值不存储，而是通过计算出来[比如 age]】



## 约束

### 映射基数

#### 映射基数是什么？

- 表示一个实体通过一个联系集能关联的实体的个数

#### 映射基数的分类

##### 1-1

##### 1-n

##### n-1

##### n-n

### 参与约束

#### 什么样的参与是全部[total]的？

- 若实体集E中的**每一个实体**都参与到联系集R中，那么说实体集E在联系集中的**参与是全部的**

### 码

- 略

## 从实体集中删除冗余属性



## E-R图

#### 非二元的联系集的边至多只有一个箭头

- eg![image-20201203102814848](https://i.loli.net/2020/12/03/wmfVuFIKLivh2YO.png)

- 若instructor的边上有箭头，表示1个student在每一个project上只有一个instructor，【其中需要注意的是，student可以有多个project】

#### 什么是弱实体集？

- 没有足够的属性以形成主码的实体集称为弱实体集
- 其中弱实体集必须和一个**属主实体集**关联才能有意义，若实体集与属主实体集相连的联系称为**标识性联系**、

#### 为什么不把分辨符直接加入弱实体集中变为主键？

- 因为会产生数据的冗余



#### 什么是强实体集？

- 有主码的实体集

#### 什么是弱实体集的分辨符[部分码]？

- 用于和属主实体集关联**构成伪主码的属性**称为弱实体集的分辨符
- eg：section的分辨符是{sec_id,year,semester}

#### 分辨符在ER图中如何表示？

- 用虚下划线标明
- 关联弱实体集和属主实体集的联系集用**双棱形**表示

![image-20201122113440789](https://i.loli.net/2020/11/22/SidvlWGzeHIZU5V.png)



## 转换为关系模式

### 具有简单属性的强实体集的表示

- 直接表示

### 具有复杂属性的强实体集的表示

#### 如何处理复合属性？

- 并不为复合属性自身创建单独的属性，而是为**每个子属性创建单独的属性**

#### 如何处理多值属性？

- 创建新的关系模式

#### 如何处理派生属性？

- 表示为**方法**

### 弱实体集的表示

- 对于弱实体集转换来的模式，该模式的主码由其所依赖的**强实体集的主码**和**分辨符**组合而成。

### 联系集的表示

#### 如何选择主码？

- 将边上没有箭头的**所有**参与的**实体集的主码**的**并集**成为主码

#### 什么样的模式是冗余的？

- 连接**弱实体集**与所依赖的**强实体集**的**联系集的模式**是冗余的

#### 什么样的模式可以合并？

##### n-1

- ![image-20201122224121540](https://i.loli.net/2020/11/22/1pnfPUC2FM98Sjq.png)

- 这样的模式，可以把sec_time_slot和section合并

##### 1-1

- 联系集可以和参与联系任何一个实体集合并



#### ISA如何表示

- 继承，但是要包含父类的主键
- 包含

## 实体-联系设计问题

### 属性还是实体集

- 一个常见的错误是用一个实体集的主码作为另一个实体集的属性，而不是使用**联系集**
- 可以先假设它是属性再判断是否可行

### 实体集还是联系集

#### 什么时候使用联系集？

- 当描述发生在实体间的行为时采用联系集
- 联系集的主键一定是参与的实体集的主键
- 先假设是联系集，假如不行则改为实体集

### 二元还是n元联系集

#### 如何将n元联系集变成2元联系集？

##### 1

- ![image-20201123155432621](https://i.loli.net/2020/11/23/OTPmXgokAc5JjIH.png)

- 其中E的属性有：原来R的属性加上再定义的主键

##### 2

![image-20201202213951547](https://i.loli.net/2020/12/02/L75iXg4rwKebDpF.png)

### 联系属性的布局

- 1-1和1-n的联系集的属性可以放到参与该联系集的实体集中，而不是放到联系集中

## 扩展的E-R特性

### 特化是什么？

- 在**实体集内部进行分组**的过程成为特化
- 比如person 分组为employee 和student

#### 重叠特化是什么？

- 一个实体集可以属于多个特化实体集【多个箭头表示】

#### 不相交特化是什么？

- 一个实体集至多属于一个特化实体集【使用一个箭头】

![image-20201122225157704](https://i.loli.net/2020/11/22/GDkEuKOpb4InMzw.png)





### 概化

- 特化的逆过程

### 属性继承

#### 什么是单继承

- 低层实体集只参与到一个ISA联系中

#### 什么是多继承

- 低层实体集可以参与到**多个ISA联系**中，且产生的结构称为**格**

### 概化上的约束

#### 约束的分类

##### 条件定义的【高层实体集由谓词显示定义产生低层实体集】

##### 用户定义的

###### 不相交约束【1个实体集至多属于1个低层实体集】

###### 重叠【属于多个】

##### 完全性约束

###### 全部概化\特化

- 每个高层实体集必须属于一个低层实体集

###### 部分概化\特化【默认】

- 允许一些高层可以不属于任何低层

### 聚集【和SQL中的聚集不同】

#### 联系集与联系集的联系如何表示？

- 使用聚集

##### 为什么使用聚集而不使用其他方法？

- 其他方法会导致数据的冗余

#### 什么是聚集？

- 聚集是一种**抽象方法**，通过这种抽象，可以把**联系**看作是一种**高层实体**

#### eg

- 本图中的上半图就是通过聚集抽象来构造的

![image-20201123161047239](https://i.loli.net/2020/11/23/OV3rdqcsPpHNjwn.png)

- eval_for的主键是instructor和project 和student的主键




### 转换为关系模式

#### 概化的转换

- 若概化是完全的且是不相交的，那么可以不为高层实体集创建模式，**仅为低层实体创建模式**





# 8关系数据库设计

- 正则
- 3nf
- bcnf 





## 1好的关系设计的特点

### 1更大的模式

- 带来的问题：导致存在大量的空值

### 2更小的模式

- 带来的问题：有损分解

#### 函数依赖是什么？

- 存在这样的一条规则，如果存在模式(dept_name,budget)，则dept_name 可以作为主码，这条规则定义为函数依赖。记作
  $$
  dept\_ name \rightarrow budget
  $$
  
- 

#### 有损分解

- 不仅仅是元组的丢失，元组的增加也能称之为有损分解

#### 无损分解

- 反之

## 2原子域和第一范式1NF

### 什么域是原子域？

- 一个域是原子的，假如该域的**元素**被认为是不可分的单元。

### 什么样的关系模式R属于第一范式

- 如果R的所有属性的域都是原子的，那么我们称R属于第一范式。

### 是否原子只需要满足数据库的设计即可，没有必要一定说明可拆分就是非原子



## 3使用函数依赖进行分解

### 码和函数依赖

#### 关系的合法实例

- 一个关系的满足所有这种现实世界约束的实例称之为关系的合法实例。

- 常用的现实世界约束形式化表示为**码**



- 一个实例满足**函数依赖**$\alpha \rightarrow \beta$的条件是：对于实例中的**所有**元组对$t_1$和$t_2$，若$t_1[\alpha]=t_2[\beta]$，则$t_1[\beta]=t_2[\beta]$
- 如果r(R)的每个合法实例都满足**函数依赖**，则我们说该函数依赖在模式r(R)上是**成立**的
- 值得注意的是一个实例满足（现实世界中的一个合法实例），并不代表现实世界中的所有实例都满足。



#### 平凡依赖

- 如果$\beta \subseteq  \alpha$，则$\alpha \rightarrow \beta$这样的依赖称之为平凡依赖



#### 函数依赖集F的闭包

- F的闭包是 能从F集合中推导出的所有函数依赖的集合，称之为$F^+$



### Boyce-Codd范式 BCNF

- 它能消除所有基于函数依赖能发现的冗余

#### 哪些关系模式R属于BCNF？

- 具有函数函数依赖集合F的关系模式R属于BCNF的条件，对于$F^+$中的所有形如$\alpha \rightarrow \beta$的函数依赖，至少成立一项
  - $\alpha \rightarrow \beta$是平凡依赖，即$\beta \subseteq \alpha$
  - $\alpha$是模式R的一个超码

#### 如何去分解不属于BCNF的模式？

- 不妨假设存在至少一个非平凡的函数依赖$\alpha \rightarrow \beta$，其中$\alpha$不是R的超码，我们将其分解为
  - $(\alpha \cup \beta)$
  - $R-(\beta -\alpha)$
- 递归分解



### 一些BCNF分解不能保持依赖

- 但是我们希望能够保持依赖：（



### 2NF

- 只有历史意义，不再使用了

### 第三范式3NF

- 比BCNF弱，允许我们保持依赖

#### 哪些关系模式R属于3NF

- 满足BCNF

- **或者** 
  $$
  对于\beta - \alpha 的每一个属性A\\
  A\subseteq “关系模式R的候选码”
  $$

- **注意**，属性A可以包含于**不同**候选码的属性

### 更高的范式【更强的范式】

- 这样的范式并不是基于函数依赖【也可以看出BCNF，1NF，3NF都是基于函数依赖】
- 所以定义了其他的依赖和范式【见**使用多值依赖的分解**】



## 4函数依赖理论

### 函数依赖集的闭包

#### 逻辑蕴含是什么？

- 给定关系模式r(R),如果r(R)的每一个满足F的实例都满足f，则R上的函数依赖f被r上的r上的函数依赖**集**F逻辑蕴含。
- 【即，可以通过函数依赖**集**F可推出f】

#### 函数依赖集F的闭包是什么？

- 是被F逻辑蕴含的所有函数依赖的集合，记作$F^+$

#### Armstron公理

- 自反律
- 增补律
- 传递律

##### Armstron公理引理

- 合并律
- 分解律
- 伪传递律





### 属性集的闭包

#### 什么是函数确定？

$$
若【属性集】a\rightarrow 【属性】B , 我们称属性B被a【函数确定】
$$

#### 如何判断属性集a是否超码

- 一种方法是计算$F^+$，找出所有左半部为$a$的函数依赖，合并这些函数依赖的右半部分，判断是否**所有的属性的集合，开销大**
- 使用**闭包 **，检查$a^+$是否包含R中的所有属性

#### 属性闭包$a^+$

$$
F下的a的闭包：函数依赖集F下被a函数确定的所有属性的集合\\
即 \{ B| a\rightarrow B ，使用F\}
$$



### 正则覆盖

#### 无关属性【属性的无关性是相对于函数依赖来表达的，所以去除无关属性也是在函数依赖中去除的】

- 去除函数依赖中的一个属性不改变该属性依赖集的**闭包**，则称该属性是无关的

- 形式化定义：考虑函数依赖集F以及F中的函数依赖$a\rightarrow \beta$
  $$
  如果A\in a 并且F逻辑蕴含(F-\{ a\rightarrow \beta\})\cup \{ (a-A)\rightarrow \beta\},则称属性A在a中是无关的\\
  如果A\in \beta 并且函数依赖集F^{'}\{F-\{ a\rightarrow \beta \}\}\cup \{a\rightarrow (\beta - A)\}逻辑蕴含F，则称属性A在\beta 中是无关的
  $$



#### 检验属性是否无关

- 若$A\in \beta$，计算$F^{'}$下的$a^+$,若$a^+$包含A，则A在$\beta$中是无关的
- 若$A\in a$ ，令$\gamma = \alpha -\{A\}$，若F能推出$\gamma \rightarrow \beta$则称A在a中是无关的
- **目测**

#### 正则覆盖依赖集$F_c$

- 【理解为精简后的$F$】

正则覆盖集$F_c$需要满足以下条件

1. $F逻辑蕴含F_c，且 ，F_c 逻辑蕴含F$ 也就是说$F_c^{+}= F^+$
2. $F_c$中的函数依赖都不含无关属性
3. $F_c$中的函数依赖的左半部都是唯一的

#### 如何计算正则覆盖集$F_c$

1. 合并左边相同的属性集【增补律】
2. 去除无关属性
3. 可得正则覆盖

- 例

  ![屏幕截图 2020-10-28 204652](https://i.loli.net/2020/10/28/xcJyZh1YP4AIaf3.png)





### 无损分解

#### 什么是无损分解？

- R分解为两个模式A和B，用A和B替代R的时候没有信息损失，称该分解是无损分解

- 更为形式化的：对于所有合法的数据库实例，当关系r包含与下述SQL查询结果相同的元组集

  ```sql
  select *
  from (
  	(select A from R)
  	natural join
  	(select B from R)
  );
  ```


#### 无损分解的判定

$$
R分解为R_1和R_2\\
若R_1\cap R_2 \rightarrow R_1 或者R_1\cap R_2 \rightarrow R_2则它们是无损分解
$$



### 保持依赖

#### 为什么要保持依赖？

- 保证分解后的关系模式和原关系模式等价，我们要判定
  - 分解后的关系模式是否可以无损连接
  - 是否保持依赖
- [对于二者的讲解](https://blog.csdn.net/legendaryhaha/article/details/80649234)

#### 限定

$$
F在R_i上的限定是F^+中的所有只包含R_i属性的函数依赖的集合F_i\\
$$

#### 保持依赖的判定【判断它能否推出原来的依赖】

#### 保持依赖的分解

##### 充分条件【指数时间】

$$
设有F^{'}=F_1\cup F_2\cup F_3...\cup F_n\\
我们称具有性质F^{'+}=F^+的分解为保持依赖的分解\\
$$

##### 充分必要条件【多项式时间】

- 对于F中的每一个a->b

  ![屏幕截图 2020-10-28 210000](https://i.loli.net/2020/10/28/YhRFMSq8m6AIlCs.png)

- 这里的属性闭包是在F下，假如result包含b的所有属性，那么a->b保持依赖。

## 分解算法

### BCNF分解

#### 判断分解后的关系$R_i$是否BCNF的另一种判定方法

- 对于$R_i$中属性的**每一个子集a**,确保$a^+$【F下a的属性闭包】。
  - 要么不包含$R_i$-a的任何属性
  - 要么包含$R_i$的所有属性

#### 更常使用的BCNF分解法

- 判断函数依赖是否符合BCNF的条件
  - 其中对不符合条件的进行分解
- 重复上一步直至所有函数依赖都满足BCNF

- 细节说明：【检查关系R是否BCNF只需要检查F中的函数依赖即可，不需要F的闭包。可以证明2者等价】，但是对于推出的R_i而言可能需要计算F的闭包来得到其函数依赖

#### eg

![image-20201101235654309](https://i.loli.net/2020/11/02/DbQ6d8O2q1W4jTR.png)



### 3NF分解

#### 如何进行3NF分解？

1. 计算正则覆盖依赖集$F_c$
2. 使用**3NF合成算法**进行分解
3. 删除互相包含的模式集

![image-20201102000135688](https://i.loli.net/2020/11/02/ykvwQIRCmV41xPA.png)

```python
令Fc是F的正则覆盖
i=0;
//这里保证了保持依赖
for each Fc 中的函数依赖 a->b
	i=i+1;
    R_i = ab;
```





### 3NF算法的正确性

#### 保持依赖的正确性

- 为正则覆盖中的每一个**依赖**显式地构造一个**模式**来确保依赖保持

#### 无损分解的正确性

- 算法保证了至少有一个模式$R_i$包含被分解模式$R$的候选码

### BCNF和3NF的比较

#### 数据库设计的目标是什么？

- BCNF
- 无损
- 保持依赖









# 9-11

- 略

# 12事务管理

### 事务是什么？

- 构成单一逻辑工作单元的操作集合称作事务(transaction)。要么执行整个事务， 要么属于该事务的操作一个也不执行。

## 1事务概念

### 要求数据库系统维护事务的哪些性质【ACID性质】？

#### 原子性   0 or 1

- 由**恢复系统**的一个数据库系统组件来完成

#### 一致性 

- 隔离性保证了一致性

#### 隔离性

#### 持久性



### 什么是不一致状态？

- 由于故障，系统的状态**不再反映**数据库本应描述的现实世界的真实状态。我们把这种状态称为**不一致状态**

## 2事务的原子性和持久性

### 什么是事务中止？

- 事务未能成功执行完毕

### 什么是事务回滚？

- 中止事务造成的变更被撤销，称为事务回滚。

### 什么是事务已提交？

- 成功完成执行的事务称为已提交

### 如何撤销已提交事务？

- 撤销已提交事务所造成影响的唯一方法是执行一个**补偿事务**(compensating transaction)，而不是roll back，这个责任是交给用户来实现。



### 事务的状态

#### 事务有哪些状态？

##### 活动的

##### 部分提交的

##### 提交的

##### 失败的

##### 中止的



#### 事务状态转换图

![image-20201102170745889](https://i.loli.net/2020/11/02/nzBfyHieWq7CuUp.png)

#### 事务进入中止状态后，系统的2种选择

##### 重启事务

- 仅当引起事务中止的原因是硬件错误，而不是内部逻辑错误

##### 杀死事务

- 由于内部逻辑错误



## 3事务隔离性

### 为什么要允许事务并发？

#### 提高吞吐量和资源利用率

#### 减少等待时间

### 系统如何防止事务之间的交互破坏一致性？

- 系统通过“并发控制机制”

### 什么是调度schedule?

- 表示指令在系统中的执行的时间**顺序**

## 4可串行性

### 什么是冲突？

- 当I与J是不同事务在相同的数据项上的操作，并且其中至少有一个`write`指令时，我们说I与J是冲突的。

### 什么是冲突等价【是对于2个调度而言的】？

- 如果调度S经过一系列非冲突指令转换成$S^{'}$，则称S和$S^{'}$是**冲突等价**的

### 什么是冲突可串行化？

- 若一个调度S和一个串行调度**冲突等价**，则称调度S是冲突可串行化的。

### 什么是可串行化？

- 若一个调度可等价于一个**串行调度**，则称该调度是可串行化的

### 冲突可串行化和可串行化

- 满足冲突可串行化一定满足可串行化，满足可串行化不一定满足冲突可串行化



## 5可恢复性

### 什么是可恢复调度？

- 一个可恢复调度应该满足：对于每对事务$T_i$和$T_j$，如果$T_j$读取了之前由$T_i$所写的数据项，**则$T_i$先于$T_j$提交**

![image-20201105140013646](https://i.loli.net/2020/11/05/Zhbo6YIektlqGwD.png)

- 这个例子是不可恢复调度的，因为$T_7$的commit在$T_6$结束之前就提交了

### 什么是级联回滚？

- 因为单个事务故障导致了一系列事务回滚的现象称为级联回滚。

### 什么是无级联调度？

- 无级联调度应该满足：对于每对事务$T_i$和$T_j$，如果$T_j$读取了先前由$T_i$所写的数据，则$T_i$必须在$T_j$**这一读操作**前提交。

### SQL标准规定的隔离性级别【由高到低】

#### 可串行性

#### 可重复读【只允许读已提交事务的数据，但是可重复】

#### 已提交读【只允许读已提交事务】

#### 未提交读

- 所有隔离性级别读不允许**脏写**

### 什么是脏写？

- 若一个数据项已经被另外一个尚未提交或者中止的事务写入，仍对该数据执行写操作，这就是脏写

## 6并发控制

### 并发控制中最常用的机制

#### 两阶段锁封锁

#### 快照隔离

### 基于锁的协议

- 若忽略死锁和饥饿，则基于锁的协议的并发属于可串行化的

#### 锁的种类

##### 共享锁lock-S(Q)

- 若事务T获得了数据项Q上的共享锁，则T可读，但是不能写，一个数据源可以加多个共享锁

##### 排他型锁lock-X(Q)

#### 锁的相容性是什么？

- 令A与B代表任意的锁类型，假设事务Tj 请求对数据项Q加A类型锁， 而事务Ti当前在数据项Q上拥有B类型锁。尽管数据项Q上存在B类型锁，如果事务Tj 可以立即获得数据项Q上的锁，则称A类锁和B类锁是相容的

- 若事务T获得了数据项Q上的共享锁，则T可读，又能写

![image-20201105143529403](https://i.loli.net/2020/11/05/jgmRbBQr3OJ59tT.png)

- 本节2类锁的相容性描述。



#### 什么是死锁？

- 一种哪个事务都不能正常执行的状态

#### 死锁发生了应该怎么做？

- 系统必须回滚2个错误事务中的一个。
- 回滚可以解决死锁，但是无法解决饿死

#### 什么是饿死？

- 事务T可能永远都得不到排他锁【也就是永远不能取得进展】

#### 如何避免饿死？

- 当事务T申请对数据Q加M型锁的时候，并发控制管理器授权加锁的条件是
  - 不存在在数据项Q上持有M型锁冲突的锁的其他事务
  - 不存在等待对数据Q加锁且先于T申请加锁的事务

#### 两阶段封锁协议

##### 两阶段封锁协议是什么？

- 该协议要求每一个事务分为2个阶段提出加锁和解锁申请
  1. 增长阶段：事务可以获得锁，但是不能释放锁
  2. 缩减阶段：事务可以释放锁，但是不能获得新锁
- 两阶段封锁协议保证了**冲突可串行化**

##### 两阶段封锁协议如何解决级联回滚？

- 将两阶段的封锁修改为严格两阶段协议【要求事务锁有**排他锁**必须**在事务提交[commit]后**才释放】
- 这样的协议称为**强**两阶段封锁协议：要求事务提交前不能释放**任何锁**

##### 增加锁会产生什么问题？

- 死锁
- 饥饿



#### 多粒度

##### 为什么要使用多粒度机制？

- 因为事务访问多个数据项的时候，则需要加多个锁，而这些加锁操作是很**费时**的

##### 什么是多粒度机制？

- 小粒度数据项嵌套在大粒度数据项中实现，可以图形化表示为**树**

![image-20201112141018215](https://i.loli.net/2020/11/12/XcWZiBbpMazd1HO.png)

##### 系统是怎样判定根结点是否可以加锁呢？ 

- f1：搜索整个树【但是破坏了多粒度机制的初衷】
- f2：引入**意向型锁**：在一个结点显式加锁之前， 该结点的全部祖先结点均加上了对应的意向锁

##### 锁的添加和释放

- 加锁是按自顶向下【根到叶】
- 释放锁是自底向上【叶到根】

##### 相容性矩阵

![image-20201112141355515](https://i.loli.net/2020/11/12/UgOm5BiFku3NJPl.png)



### 基于时间戳的协议

#### 什么是基于时间戳的协议？

- 对于每一个事务T，在事务执行前，数据库赋予了它一个唯一的固定时间戳和它联系在一起，记作TS(T)
- 若此时有新事务B进入系统，则TS(T)<TS(B)

#### 实现时间戳协议的2种方法

##### 系统时间

##### 逻辑计数器

#### 时间戳的具体算法

- 若**事务T回滚**，则系统赋予它新的时间戳并启动

![image-20201112150320048](https://i.loli.net/2020/11/12/hVeBYldgPUNcW68.png)

#### 时间戳有死锁吗？

- 无死锁，因为不存在等待的事务

#### 时间戳有饿死吗？

- 当一系列冲突的短事务引起长事务反复重启时， 可能导致长事务饿死的现象

### 基于有效性检查协议

#### 有效性检查算法过程

- Start(T) : 事务T, 开始执行的时间。保存在事务T的局部变量中，所有写操作都在局部变量中进行
2. Validation(T) : 事务T, 完成读阶段并开始其有效性检查的时间。判断是否可以执行`write`而不违反**可串行性**，若有效性检查失败，则终止这个事务
3. Finish(T) : 事务T, 完成写阶段的时间。把局部变量中的内容复制到数据库中相当于`write`

#### 通过有效性检查的条件，满足之一

事务T,的有效性测试(validation test )要求任何满足TS(T1) <TS(T2)的事务必须满足下面两条件之一

1. Finish(T1) < Start(T2)。
2. Start(T2)<Finish(T1)<Validation(T2)

#### 有效性检查协议存在级联回滚吗？

- 有效性检查协议自动预防级联回滚

#### 存在饿死的情况吗？

- 存在长事务饿死

### 3种协议的比较

- 在有效性检查机制中，由于事务乐观地执行，假定它们能够完成执行并且最终有效，因此也称为乐观的井发控制机制。
- 与之相反，封锁和时间戳排序是悲观的，因为当它们**检测到一个冲突**时，它们强迫事务等待或回滚，即使该调度有可能是冲突可串行化的。【换句话来说，封锁和时间戳根本不允许**冲突的存在**

## 7恢复系统

### 故障分类

#### 事务故障

##### 造成的原因

###### 逻辑错误

###### 系统错误【比如死锁】

#### 系统崩溃

#### 磁盘故障

### 数据访问

#### 磁盘和主存之间的移动

- input(B)传送物理块B到主存
- output(B)传送缓冲块B到磁盘，并替换相应的块

#### 事务T的工作区和数据库的交互

![image-20201112155113485](https://i.loli.net/2020/11/12/2YOTvpoQyrxRJgf.png)

### 恢复与原子性

#### 如何确保已提交的事务所做的修改都反映到数据库中【故障后恢复的数据库中】？

- 在修改数据库本身前，先向稳定存储器输出**描述信息**，描述所要做的修改

#### 日志记录

##### 什么是日志？

- 日志是日志记录的序列，记录数据库中素有的更新活动

##### 日志记录的字段

![image-20201112160357407](https://i.loli.net/2020/11/12/aKr4VXIQyueCfJY.png)

- 形式化表示为$<T_i,X_j,V_1,V_2>$

##### 日志存放在哪里？

- 日志必须存放在稳定存储器中



##### eg 日志例子

<img src="https://i.loli.net/2020/11/12/nxalv5bdsGPMIut.png" alt="image-20201112202144895" style="zoom:50%;" />

![image-20201112202156890](https://i.loli.net/2020/11/12/KUM2TYEPghj3FR4.png)

- 若故障恰好发生在以下3个时间点

![image-20201112202452071](https://i.loli.net/2020/11/12/gcHvAerIoi6LDtf.png)

- a：undo(T0)，重启后：A:1000,B:2000
- b：redo(T0),undo(T1) 重启后： A：950，B：2050，C：700
- c：redo(T0),redo(T1)重启后： A：950，B：2050，C：600



#### 数据库修改

##### 延迟修改技术

- 如果一个数据库在提交时都没有修改数据库，那么我们说它采用了延迟修改技术

###### 延迟修改所带来的代价

- 事务需要创建更新过的所有的数据项的本地拷贝

##### 立即修改技术

- 如果一个数据库在修改事务时仍然活跃，我们说它采用了**立即修改技术**

##### 恢复算法考虑的因素

- 一个事务已经提交，但是所做的修改只是在数据库**主存缓冲区**
- 一个事务未提交但是已经修改，但是后来发生故障，事务被中止

##### undo和redo

- undo使用一个日志记录，将数据项置为旧值
- redo使用一个日志记录，将数据项置为新值

#### 事务提交

##### 什么样的事务是提交的？

- 当一个事务的c ommit日志记录－这是该事务的最后一个日志记录：**输出到稳定存储器**后，我们就说这个事务提交(commit)了

#### 检查点

- 大概的过程还没有深入理解

##### 为什么不搜索整个日志而使用检查点？

- 搜索过程太耗时
- 恢复过程过长

##### 什么是模糊检查点？

- 即使在缓冲块**正在写出时也允许事务执行更新**的检查点







## 8总结



# 14





# 其他

- 属性集$\alpha$
- 关系模式$r(R)$
- 超码$K$
- 

## 多值属性的处理

- 变成类似复合属性的属性
- 变成一个实体集

## 存储器的分类

### 易失性存储器

### 非易失性存储器

### 稳定性存储器

- 尽量避免级联回滚



- 冲突可串行化

## 表达一致性约束的方式

### 主码约束

### 函数依赖

### check约束

### 断言

### 触发器



## 多值属性

- 多值属性的每一个属性对应一个模式



- 正则覆盖不一定唯一







### 原子性

### 一致性

### 持久性



## 若一个ER图有环说明什么？

- 说明2个实体集间一定有2种不同的联系。



## 如何判断转换的模式是否合理？

- 将转换的模式做自然连接，判断自然连接的模式的实体是否和原来的一致



## 非二元联系集中为什么至多只有一个箭头？

- 假设实体集A1,A2,A3之间有联系集R，且A1，A2的边有箭头，那么会有2种解释
  - R的主码可以使用A3的主码来构造
  - 对于A1，来自A2，A3的至多一个实体关联，所以A2和A3的主码构成了R的主码





# 简答












- 用户创建

```sql
create user c##Xxgzbd identified by Orcl1234;
```



# 表

- 创建表

  ```sql
  create table table_name(
  	Field_name type 	
      constraint PK_name primary key (Field_name)
  );
  ```

```sql
example
create table locations(
	lid char(4) not null,
    city varchar2(20) not null,
    address varchar2(100) not null,
    
    postcode char(6) null,
    constraint locations_lid_pk primary key(lid)
);
```



```
//Q: what is difference between varchar2 and varchar :
varchar2 使得 ''变为NULL
...
```





## delete 

- 删除元组

```
delete from table_name 
where [谓词]
```

```sql
//example1
delete from locations
where lid in ('1');
//example2
delete from locations
where lid not in (select lid from locations);
```

- ```sql
  delete from student;//删除所有元组
  ```



## drop

- 删除关系

- ```
  drop table r
  ```

  



## alter

- 修改属性

- ```sql
  alter table r add A D;//增加新属性A
  ```

- ```sql
  alter table r drop A;//去掉属性A
  ```



- 



## 查询

```sql
select name
from instructor
```



```sql
select name
from instructor
where dept_name = 'Comp. Sci.' and salary > 70000;//带条件查询
```





```sql
create table department
(dept_name varchar(20),
building varchar (15) ,
budget numeric (12 ,2) ,
primary key (dept_name)) ;

```





```sql
create table course
(course_id varchar (7) ,
title varchar (50) ,//课程名字
dept_name varchar (20),
credits numeric (2,0),
primary key (course_id),
foreign key (dept_name) references department) ;
```



```sql
create table instructor
(ID varchar (5) ,
name varchar (20) not null,
dept_name varchar (20) ,
salary numeric (8,2),
primary key (ID) ,
foreign key (dept_name) references department);
```



```sql
create table section
(
course_id varchar (8) ,
sec_id varchar (8) ,
semester varchar (6) ,
year numeric (4,0),
building varchar (15) ,
room_number varchar (7),
time_slot_id varchar (4) ,
primary key (course_id，sec_id, semester，year),
foreign key (course_id) references course
) ;
```

```sql
create table teaches
(
    ID varchar(5),//教师ID
    course_id varchar (8) ,//课程ID
    sec_id varchar (8) ,
    semester varchar(6),
    year numeric (4,0),
    primary key (ID, course_id, sec_id,semester,year),
    foreign key ( course_id,sec_id,semester,year ) references section,
    foreign key (ID) references instructor
);
```

```sql
select dept_name, count (distinct id) as instr_count
from instructor natural join teaches
where semester = 'Spring' and year =2010
group by dept_name;
```

- 

```sql
create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
```



- create

```
create table classroom
	(building		varchar(15),
	 room_number		varchar(7),
	 capacity		numeric(4,0),
	 primary key (building, room_number)
	);
 
create table department
	(dept_name		varchar(20), 
	 building		varchar(15), 
	 budget		        numeric(12,2) check (budget > 0),
	 primary key (dept_name)
	);
 
create table course
	(course_id		varchar(8), 
	 title			varchar(50), 
	 dept_name		varchar(20),
	 credits		numeric(2,0) check (credits > 0),
	 primary key (course_id),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table instructor
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 salary			numeric(8,2) check (salary > 29000),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table section
	(course_id		varchar(8), 
         sec_id			varchar(8),
	 semester		varchar(6)
		check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), 
	 year			numeric(4,0) check (year > 1701 and year < 2100), 
	 building		varchar(15),
	 room_number		varchar(7),
	 time_slot_id		varchar(4),
	 primary key (course_id, sec_id, semester, year),
	 foreign key (course_id) references course
		on delete cascade,
	 foreign key (building, room_number) references classroom
		on delete set null
	);
 
create table teaches
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id,sec_id, semester, year) references section
		on delete cascade,
	 foreign key (ID) references instructor
		on delete cascade
	);
 
create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table takes
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 grade		        varchar(2),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id,sec_id, semester, year) references section
		on delete cascade,
	 foreign key (ID) references student
		on delete cascade
	);
 
create table advisor
	(s_ID			varchar(5),
	 i_ID			varchar(5),
	 primary key (s_ID),
	 foreign key (i_ID) references instructor (ID)
		on delete set null,
	 foreign key (s_ID) references student (ID)
		on delete cascade
	);
 
create table time_slot
	(time_slot_id		varchar(4),
	 day			varchar(1),
	 start_hr		numeric(2) check (start_hr >= 0 and start_hr < 24),
	 start_min		numeric(2) check (start_min >= 0 and start_min < 60),
	 end_hr			numeric(2) check (end_hr >= 0 and end_hr < 24),
	 end_min		numeric(2) check (end_min >= 0 and end_min < 60),
	 primary key (time_slot_id, day, start_hr, start_min)
	);
 
create table prereq
	(course_id		varchar(8), 
	 prereq_id		varchar(8),
	 primary key (course_id, prereq_id),
	 foreign key (course_id) references course
		on delete cascade,
	 foreign key (prereq_id) references course
	);
 
```







```
select max(tot_salary)
 from (select dept_name,sum(salary) as tot_salary
from instructor
  group by dept_name )
   dept_total ;
```











- `with`

```sql
with max_budget (value) 
as (select max(budget)
from department)
select budget
from department,max_budget
where department.budget = max_budget.value;
```



```sql
with 
dept_total(dept_name,value)as
(select dept_name,sum (salary)
 from instructor
 group by dept_name),
dept_total_avg (value) as
(select avg(value)
from dept_total)
select dept_name
from dept_total,dept_total_avg
where dept_total.value >=dept_total_avg.value;
```

- 标量子查询

```
select dept_name,
(
select count(*)
from instructor
where department.dept_name = instructor.dept_name
)
as num_instructors
from department;
```



- ```
  
  SQL> create view physics_fall_2009 as
  select course.course_id,sec_id,building,room_number
     from course,section
      where
      course.course_id = section.course_id
      and course.dept_name = 'Physics'
      and section.semester ='Fall'
      and section.year = '2009'
      ;
  ```

  



- ```sql
  date'2001-04-25'
  time'09: 30: 00'
  timestamp'2001-04-2510:29:01.45'
  ```

  





# 一些语句

- 请用 SQL语句中的select子句表达：统计各个学院内老师的数量。

  ```
  select dept_name ,(
  select count(*) 
  from instructor 
  where department.dept_name = instructor.dept_name
  ) as num_instructors
  from department;
  ```

- 找到选了生物学院所有开设的课程的学生

  ```
  select distinct S.id,S.name
  from student as S
  where not exists (
  	(
  		select course_id
  		from course
  		where dept_name ='Biology'
  	)except(
  		select T.course_id
  		from takes as T
  		where S.ID = T.ID
  	)
  )
  ```

  





- 写一个过程*dept_count_proc*，计算某一学院的教师数量。输入形参为学院的名字。

  ```sql
  create procedure dept_count_proc (in dept_name varchar(20),out d_count integer)
  begin
  	select count(*)into d_count
  	from instructor
  	where instructor.dept_name = dept_count_proc.dept_name
  end;
  ```

  