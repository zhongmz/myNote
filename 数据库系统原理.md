# 1引言

## 一些定义

### 数据库系统是什么？

- 由一个互相**关联**的数据的集合和一组用以访问这些数据的**程序**组成。

### 数据库是什么？

- 这个**数据集合**通常称作数据库(database)

### 数据库系统的主要目的是什么？

- 给用户提供数据的抽象视图， 也就是说， 系统隐藏关于数据存储和维护的某些细节。

## 数据库系统的目标

### 文件处理系统中存储组织信息的弊端

#### 数据冗余和不一致（重复，并且不一致）

- data redundancy and inconsistency 

####  数据访问困难（索引困难）

- difficulty in accessing data

#### 数据孤立（不同文件，不同格式）

- data isolation 

#### 完整性问题（难以满足新的约束）

- integrity problem 

#### 原子性问题

- atomicity problem 

#### 并发访问异常（文件互斥访问过于束缚）

- concurrent - access anomaly 

####  安全性问题

- security problem

## 数据视图

### 数据抽象

#### 数据抽象的层次

#### physical level 物理层，如何存储

#### logical level 逻辑层，确定数据库中需要存储什么信息

#### view level 视图层，隐藏部分数据，用户所看到的是这些视图

![数据抽象的3个层次](https://i.loli.net/2020/08/26/BtgSU9Zwr6WnIpM.png)





### 实例和模式

#### 什么是实例？

- 数据库的一个实例`instance`是特定时刻存储在数据库中的信息的**集合**，相当于值

#### 什么是模式？

- 数据库模式是数据库的总体设计，不发生变化，即使发生变化也不频繁，相当于变量

#### 有几种模式？ 

##### 物理模式

##### 逻辑模式

##### 子模式【本质上是视图层的模式】

- 物理模式隐藏在逻辑模式下，并且通常可以在应用程序丝毫不受影响的情况下被轻易地更改

#### 物理数据独立性是什么？

- 应用程序如果不依赖于物理模式，即使物理模式发生改变数据也不需要重写。

### 数据模型

#### 数据模型是什么？

- 数据模型是一个描述**数据**、数据**联系**、数据**语义**以及**一致性约束**的概念工具的集合。

#### 有哪些数据模式？

##### 关系模型

##### 实体关系模型

##### 基于对象的数据模型

##### 半结构化数据模型 (XML)

##### 网状数据模型

##### 层次数据模型

## 数据库语言

### DML 数据操纵语言

#### DML是什么？

- 用户可以访问或操纵那些按照某种适当的数据模型组织起来的数据。

- 检索
- 插入
- 删除
- 修改

#### DML的2种基本分类

##### 过程化 DML

- 要求用户指定需要什么数据以及**如何**获得这些数据。

#### 声明化DML

- 只要求用户指定需要什么数据

### DDL 数据定义语言

#### 什么是DDL？

- 定义数据的其他特征。

#### 什么是数据存储和定义语言？

- 一种特殊的数据定义语言
- 说明了数据库系统所使用的**存储结构**和**访问方式**

#### 一致性约束有哪些？

##### 域约束【即定义域】

##### 参照完整性【即外键】

##### 断言

- 一个断言就是数据库需要时刻满足的某一条件。

##### 授权【即权限的约束】

###### 读权限

###### 插入权限

###### 更新权限

###### 删除权限

#### 什么是数据字典

- DDL生成的输出放在数据字典中，数据字典中有元数据
- 数据字典可看做是一个特殊表



## 关系数据库

## 数据库设计

### 实体-联系模型【E-R数据模型】

#### 实体通过什么来描述？

- 属性

#### 联系是什么？

- 联系是几个实体之间的关联

#### 实体集是什么？

- 同一类型的所有实体的集合

#### 联系集是什么？

- 同一类型的所有联系的集合

### 规范化

#### 为什么要规范化？

- 生成一个关系模式集合，使我们存储信息时没有不必要的冗余，同时又能很轻易地检索数据。

## 数据存储和查询

### 存储管理器

#### 存储管理部件有哪些？

##### 权限及完整性管理器

##### 事务管理器

##### 文件管理器

##### 缓冲区管理器

#### 存储管理部件实现了哪些数据结构？

##### 数据文件

##### 数据字典

##### 索引

### 查询处理器

#### 查询处理器组件

##### DDL解释器

##### DDL编译器

##### 查询执行引擎

## 事务管理

### 事务管理器包括什么？

#### 恢复管理器

##### 恢复管理其的职责？

- 原子性
- 持久性

#### 并发控制管理器

- 保证了数据库的一致性



### 客户服务器系统

#### 两层体系结构

- 应用程序在客户机，客户使用查询语句来调用服务器上的数据库系统功能

#### 三层体系结构

- 客户端通过表单界面和应用服务器通信
- 然后应用服务器和数据库系统通信来访问数据

![系统体系结构](https://i.loli.net/2020/08/26/Imyf1hiA8aKCBXD.png)



### 并行数据库系统

#### 分类

##### 粗粒度并行机

##### 细粒度并行机

#### 性能度量方式

##### 吞吐量

##### 响应时间

### 分布式数据库系统

#### 为什么要分布式？

##### 数据共享

##### 自治性

##### 可用性







# 2关系模式介绍

## 关系数据库结构

### 关系【relation】是什么？

- 表示`代表`

### 元组【tuple】是什么？

- 表示【行】

### 属性【attribute】是什么？

- 表示列

### 域【domain】是什么？

- 一个属性允许取值的集合称之为该属性的域

### 空值【null】是什么？

- 一个特殊的值，表示未知或者不存在

## 数据库模式

### 模式和实例【schema  and instance】

- 模式是数据库的逻辑设计，实例是给定时刻中数据库数据的一个快照

## 码

### 超码【superkey】是什么？

- 超码是一个能**唯一标识**一个元组的**属性集合**

### 候选码【candidate key】是什么？

- 最小超码【它的任意真子集都无法成为超码】

### 主码【primary key】是什么？

- 代表被数据库设计者所选中的，用来区分不同元组的候选码**候选码**

### 外码【foreign key】是什么？

- 注意：有**参照关系**才存在外码的概念
- 若一个关系模式$r_1$在它的属性中包括另外一个关系模式$r_2$的**主码**，这个属性在$r_1$上称作**参照**$r_2$的外码

### 参照关系【referencing relation】是什么？

- 关系$r_1$称为外码依赖的参照关系

### 参照完整性【integrity】约束是什么？

- 在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值。



## 模式图

- 注意和E-R图不是一个东西

- 没有**显性**表示出参照完整性约束

- 长这个样子

  ![屏幕截图 2020-10-31 114333](https://i.loli.net/2020/10/31/lY2njcukB9QCTSM.png)

## 关系查询语言

- 定义了一组运算集，以表为输入，返回一个表

## 关系运算

- 提供了一组运算，以一个或多个关系为输入，返回一个关系





# 3SQL

### SQL是什么？

- SQL是一种数据库查询语言
- 本篇所描述的SQL特征是SQL-92

### SQL包括几个部分？

#### 数据定义语言

#### 数据操纵语言

#### 完整性

#### 视图定义

#### 事务控制

#### 嵌入式SQL和动态SQL

#### 授权

## SQL数据定义

### 基本类型

##### char(n)  固定长度的字符串，用户指定长度n

##### varchar(n)   可变长度的字符串，用户指定最大长度n

##### int   整数

##### smallint  小整数

##### numeric(p,d)    定点数  

- p位数字
- d位数字在小数点右边
- 1位符号位

##### real,double precision   浮点数和双精度浮点数

##### float(n)   精度至少为n位的浮点数

### 基本模式定义

#### 定义SQL关系【create table】

```sql
create table department
	(dept_name varchar(20),
	building varchar(15),
	budget numeric(12,2),
	primary key(dept_name));
```

##### 有哪些完整性约束？

###### primary key

```
eg primary key(dept_name,building)
```

###### foreign key

```sql
eg foreign key(course_id,sec_id) references section
```

###### not null 

```sql
eg name varchar(20) not null,
```

#### 删除元组【delete 】

- 注意是**元组**

##### 删除所有元组

```sql
delete from r;
```

#### 删除关系【drop】

```sql
drop table r
```

##### 增加属性【alter 】

```sql
alter table r add A D;
```

- 其中r是现在关系的名字
- A是添加属性的名字
- D是添加属性的域

## SQL查询【select】的基本结构

- 由子句`select from where `构成

### 单关系查询

#### 【distinct】在select 中去重

```sql
select distinct dept_name
from instructor;
```

#### 【all】在select 中 查询所有（即不去重）

```sql
select all dept_name
from instructor;
```



#### select 子句可进行算术运算

```sql
select distinct dept_name,salary * 1.1
from instructor;
```

#### where

- 选出那些在from的关系中满足特定谓词的元组

##### eg

- 找出所有在Comp.Sci.中且工资超过70000美元的教师的姓名

```sql
select name
from instructor
where dept_name = "Comp.Sci." and salary > 70000;
```

### 多关系查询

#### eg  多表查询

- #### ＂ 找出所有教师的姓名，以及他们所在系的名称和系所在建筑的名称＂ 

```sql
select name ,department.dept_name ,building
from INSTRUCTOR,department
where INSTRUCTOR.DEPT_NAME = department.dept_name;
```

- from r1,r2可以看做是做笛卡尔乘积【但是实际并不是】

#### 思考的顺序

1. from 子句中列出关系产生的**笛卡尔积**
2. where  子句 使用谓词
3. select  子句输出指定的属性

#### from的本质

- 定义了该子句列出关系的笛卡尔积
- 即使由相同的属性也认为是不同的属性，department.dept_name 和instructor.dept_name 认为是不同的属性

```python
for each t1 in r1
	for each t2 in r2
		把 t1 t2 连接成 t
		把t加入关系中
```

### 自然连接

#### 自然连接是什么?

- 自然连接只考虑哪些在2个关系模式上都出现**所有**属性**取值相同**的元组对

##### eg 找出大学中所有讲授课程的教师，找出他们的姓名和所讲课程的标识

```sql
select name ,course_id
from instructor natural join teaches
```

```sql
select name,course_id
from instructor,teaches
where instructor.id = teaches.id
```

- 上述2者效果相同

#### r1 join r2 using (A1,A2...)

##### eg 查询“列出教师名字和它们讲授课程的名称”

```sql
select name,course_id
from instructor natural join teaches,course
where teaches.course_id = course.course_id;
```

```sql
select name,course_id
from (instructor natural join teaches ) join using (course_id);
```

- 上述结果相同

- 注意！

- ```sql
  select name ,course_id
  from instructor natural join teaches natural course;
  ```

- 这个并不是查询出想要的，因为需要dept_name和course_id相同才能连接。



## 附加的基本运算

### 更名运算【as】

```sql
old-name as new-name
```

- 在select出现时，只是修改属性名字，在where中不使用【可以从select的执行顺序来理解】
- from 子句中出现，可用于where子句

#### eg

```sql
select name as instructor_name,course_id
from instructor,teaches
where instructor.id=teaches.id
```

```sql
select T.name,S.course_id
from instructor as T,teaches as S
where T.id = S.id
```

#### 为什么要更名？

- 方便查询，打字更少

- 为了适用于需要**比较**同一个关系中的元组

- eg 查询”找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高”

  ```sql
  select distinct T.name
  from instructor as T,instructor as S
  where T.salary > S.salary and S.dept_name ="Biology";
  ```

#### 什么是【相关名称】【表别名】【相关变量】【元组变量】

- 上面4个都是一个意思，被用来重命名关系的标识，比如上述的T



### 字符串运算

- 单引号来标识字符串
- 若单引号是字符串的组成之一，则使用双引号来表示 【 "it 's right'"】

### SQL大小写敏感吗？

- 在SQL标准中是敏感的



#### like 操作符实现模式匹配

##### %：匹配任意字符串

##### _ ：匹配任意一个字符

##### eg 

- ‘Intro%' 匹配任意以'Intro'开头的字符串
- '% Comp%' 匹配含有Comp的字符串
- '___' 匹配3个字符的字符串
- '___%'匹配至少有3个字符的字符串

- 找出所在建筑名称中包含子串'Watson'的所有系名“ ，该查询的写法如下：

  ```sql
  select dept_name
  from department
  where building like '%Watson%';
  ```



### order by A 排列元组的显示次序

- 默认是升序
- order by A desc 表示降序
- order by B asc 表示升序
- 也能够在多个属性上进行

#### eg 1

- 查询“按字母顺序列出在Physics系的所有教师”

- 

  ```sql
  select name 
  from instructor
  where dept_name = 'Physics'
  order by name;
  ```

#### eg2

```sql
select * 
from instructor
order by salary desc, name asc;
```



### where 子句

#### between

```sql
where salary between 90000 and 100000;
where salary <= 100000 and salary >= 90000;
```

- 上述2者相同

### not between 

- 效果和between 相反

#### 多维判等

```sql
where instructor.id = teaches.id and dpet_name = "A";
where (instructor.id,dept_name) = (teaches.id,"A");
```

- 上述2者相同

## 集合运算

- 无论是哪一个都是对2个**相同属性**集合【表】进行运算

### union并运算

- union运算自动去重

#### eg 

- 找出在2009年秋季开课， 或者在201 0年春季开课或两个学期都开课的所有课程

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
union
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

- 若期望保留重复

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
union all
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

### intersect 交运算

#### eg

- 找出在2009年秋季和2010年春季同时开课的所有课程的集合

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
intersect 
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

### except 差运算

#### eg

- 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程

```sql
(select course id
from section
where semester ='Fall'and year= 2009)
except
(select course_id
from section
where semester ='Spring'and year = 2010) ;
```

## 空值

### 空值作为算术表达式输入

- 若算术表达式的输入为为空，其输出为空

### 空值作为逻辑表达式的输入

- 输出可以为如下值
  - true
  - false
  - unknown

### 注意！

```sql
('A',null) 和('A',null)这2个元组被认为是相同的
但是在谓词中， null = null 这个谓词公式会返回unknown，而不是true 
```

## 聚集函数

#### 什么是聚集函数？

- 聚集函数是以值的一个集合（集或多重集）为输人、返回**单个值**的函数

#### SQL中有哪些聚集函数？

##### avg  平均值

##### min  最小值

##### max  最大值

##### sum  总和

##### count  计数



### 基本聚集

#### eg 删除重复元组＋聚集函数

- 找出在2 010年春季学期讲授一门课程的教师总数【这里可能会有语义冲突，其意思是表达“在2 010年春季学期讲授课程的教师【不重复计数】】

- ```sql
  select count(distinct id)
  from teaches
  where semester = "Spring" and year = 2010
  ```

#### 注意！

- SQL不允许在`count(*)`中使用distinct，虽然从语义上来思考，使用了和没有使用是没有区别的

### group by 分组聚集

- group by子句中给出的一个或多个属性是用来构造分组的。在group by子句中的**所有属性上取值相同**的元组将被分在一个组中。
- 当没有group by的时候可以看做是一个组 

#### eg1

- 找出每一个系的平均工资

```sql
select dept_name avg(salary) as avg_salary
from instructor
group by dept_name;
```

#### eg2

- 考虑查询＂ 找出每个系在2010年春季学期讲授一门课程的教师人数”
- 关键词： 系 2010  春季学期  去重 人数【count】

```sql
select DEPT_NAME ,COUNT (DISTINCT ID)  AS INST_COUNT
from instructor natural join teaches 
where semester = 'Spring' and year = '2010'
group by dept_name;
```

#### 注意！

- select中的属性要么出现在group 中要么出现在聚集函数中。

### having子句

- having 对于 group by 相当于 where 对于from
- 即对于group by的元组进行**筛选**，**符合条件的才能被select**

#### eg

- 查询教师平均工资超过42 000美元的系

  ```sql
  select dept_name avg(salary) as avg_salary
  from instructor
  group by dept_name
  having avg(salary) >42000;
  ```

#### 超级注意！

1. from 【得到一个关系】
2. where   【是一个条件，满足条件的才能被select 或者是group up】
3. group up 假设没有group up 那么当成一组【有group up那么就说明必然有聚集函数】
4. having 对那些聚集函数和group up 中的属性进行筛选
5. select 

### 对空值和布尔值的聚集

- 除了`count(*)`外所有的聚集函数都**忽略**输入集合中的空值
- 规定空集的count运算值为0, 其他所有聚集运算在输入为空集的情况下返回一个空值。



## 嵌套子查询

### 集合成员资格 in not in

#### in测试元组是否是集合中的成员

##### eg

- ＂ 找出在2009年秋季和2010年春季学期同时开课的所有课程” 。

```sql
select distinct course_id
from section
where semester ="Spring " and year ='2010' and course_id in(
	select distinct course_id
    from section
    where semester ="Fall" and year= "2009"
);

```

#### not in

- 和in类似

#### in 和 not in都能作用于枚举类型【从其定义也可以看出】

- 找出name不是A也不是B的人

```sql
select distinct name
from instructor
where name not in ('A','B');
```

### 集合的比较 some all

#### some

##### eg

- 找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高＂

```sql
select name
from instructor
where salary > some (
	select salary
	from instructor
	where dept_name = "Biology"
);
```

- = some 等价于in
- <>some不等价于 not in



#### all

- <>all 等价于 not in
- =all 不等价于 in



### 空关系测试exists and not exists

- 这个使用的时候，一般都会有换名操作的出现

- exists作为谓词查询是否为空 若非空则返回true'
- not exists 反之

#### eg

- 找出在2009年秋季学期和2010年春季学期同时开课的所有课程

```sql
select course_id
from section as S
where semester = "Fall" and year = 2009 and exists(
		select *
		from section as T
		where semester = "Spring" and year =2010 and S.course_id  =T.course_id
	);
```

#### 什么是相关子查询?

- **相关**
- 使用了来自外层查询相关属性的子查询称作相关子查询
- 比如该节的eg

#### not exists

##### 谓词“关系A包含关系B”

- 可以理解为集合A包含集合B【元素为相同属性的值】

- ```sql
  not exists (B except A)
  ```



##### eg

- 【问题】找出选修了Biology 开设的所有课程的学生

- 【分析】 

  - 有哪些表？course表 takes 表 学生表student
  - 有哪些函数依赖？ takes 中的id依赖student的id ；takes 中的course_id间接依赖course
  - 按顺序分析 写语句

- 【写语句】

  ```sql
  select student.id 
  from  student
  where not exists(
  	(select course_id
      from  course
      where dept_name = 'Biology')
      except
     	(select takes.course_id
      from takes
      where takes.id = student.id)
  
  );
  ```

### 重复元组存在性测试unique

- 测试一个子查询的结果中是否存在重复元组
- 若只有一个元组则返回true

#### eg

- 找出所有在2009年最多开设一次的课程

- 涉及到2009那么一定存在section这个表

- ```sql
  select course.course_id
  from course  --思考哪一个表
  where unique(--再思考表的约束
  	select section.course_id
  	from section
  	where course.course_id = section.course_id
  	and section.year = 2009
  );
  ```

- 使用 **聚集函数**+ 逻辑运算符

- ```sql
  select course.course.id
  from course 
  where 1 > = (
  	select count(*)
    from section
      where section.course_id = course.course_id and section.year = 2009
  );
  ```
  

#### not unique

- 找出所有2009 年最少开设2次的课程

- ```sql
  select course.course_id
  from course  --思考哪一个表
  where not unique(--再思考表的约束
  	select section.course_id
  	from section
  	where course.course_id = section.course_id
  	and section.year = 2009
  );
  ```

### from 子句中的子查询

#### eg

- 找出系平均工资超过42 000美元的那些系中教师的平均工资

- 分析：只需要instructor这个表就可以得到答案，分两步：1，得到平均工资，2，得到满足条件的平均工资

- ```sql
  select dept_name ,avg_salary
  from (
  	select dept_name ,avg(salary) as avg_salary
      from instructor
      group by dept_name
  )
  where avg_salary >42000
  ```

- **注意**：Oracle允许对子查询结果进行重命名，也支持对表的重命名，但是不允许对关系中的**属性**进行重命名

#### 表的更名

```sql
(   ) as new_table_name(A1,A2,A3...);
```



#### eg

- 找出所有系中工资总额最大的系

- ```sql
  select max(tot_salary)
  from (
  	(select dept_name,sum(salary)
      from instructor
      group by dept_name) as dept_total(dept_name,tot_salary)
  );
  ```



### with 子句

#### 什么是with子句？

- with子句提供定义**临时关系**的方法，只对含with子句的查询有效【即 本查询】

- ```sql
  with new_table_name(A1,..) as(
  	select something
  	from sometable
      where some_condition
  )--在下一次select可以使用
  select 
  from 
  where
  ```

  

#### eg1

- 找出具有最大预算值的系

```sql
with max_budget(value)as(
	select max(budget)
    from department
)
select budget
from department,max_budget
where department.budget = max_budget.value;
```



#### eg2

- 我们要查出所有工资总额大于所有系平均工资总额的系
- 这里需要工资总额表，工资平均总额表

```sql
with 
dept_total(dept_name,value) as
(
	select dept_name,sum(salary) 
    from instructor
    group by dept_name
),--这个表可以给下一个表用
dept_total_avg(value)as
(
    select avg(value)
    from dept_total
)--上面2个表可以给接下来的正式查询使用
select dept_name
from dept_total,dept_total_avg
where dept_total.value >= dept_total_avg.value;
```



### 标量子查询

#### 什么是标量子查询？

- 一个子查询若它只返回包含**单个属性**的**单个元组**，那么这个子查询称为**标量子查询**
- **注意**，虽然其结果只有单个元组，但是它还是关系

#### eg

- 列出所有的系以及它们拥有的教师数

- `instructor`和`department`

- ```sql
  select dept_name,
  (
  	select count(*)
  	from instructor
      where instructor.dept_name = department.dept_name
  )
  from department;
  ```



## 数据库的修改



# 8关系数据库设计

## 1好的关系设计的特点

### 1更大的模式

- 带来的问题：导致存在大量的空值

### 2更小的模式

- 带来的问题：有损分解

#### 函数依赖是什么？

- 存在这样的一条规则，如果存在模式(dept_name,budget)，则dept_name 可以作为主码，这条规则定义为函数依赖。记作
  $$
  dept\_ name \rightarrow budget
  $$

#### 有损分解

- 不仅仅是元组的丢失，元组的增加也能称之为有损分解

#### 无损分解

- 反之

## 2原子域和第一范式

### 什么域是原子域？

- 一个域是原子的，假如该域的**元素**被认为是不可分的单元。

### 什么样的关系模式R属于第一范式

- 如果R的所有属性的域都是原子的，那么我们称R属于第一范式。

### 是否原子只需要满足数据库的设计即可，没有必要一定说明可拆分就是非原子

## 3使用函数依赖进行分解

### 码和函数依赖

#### 关系的合法实例

- 一个关系的满足所有这种现实世界约束的实例称之为关系的合法实例。

- 常用的现实世界约束形式化表示为**码**



- 一个实例满足**函数依赖**$\alpha \rightarrow \beta$的条件是：对于实例中的**所有**元组对$t_1$和$t_2$，若$t_1[\alpha]=t_2[\beta]$，则$t_1[\beta]=t_2[\beta]$
- 如果r(R)的每个合法实例都满足**函数依赖**，则我们说该函数依赖在模式r(R)上是**成立**的
- 值得注意的是一个实例满足（现实世界中的一个合法实例），并不代表现实世界中的所有实例都满足。



#### 平凡依赖

- 如果$\beta \subseteq  \alpha$，则$\alpha \rightarrow \beta$这样的依赖称之为平凡依赖



#### 函数依赖集F的闭包

- F的闭包是 能从F集合中推导出的所有函数依赖的集合，称之为$F^+$



### Boyce-Codd范式 BCNF

- 它能消除所有基于函数依赖能发现的冗余

#### 哪些关系模式R属于BCNF？

- 具有函数函数依赖集合F的关系模式R属于BCNF的条件，对于$F^+$中的所有形如$\alpha \rightarrow \beta$的函数依赖，至少成立一项
  - $\alpha \rightarrow \beta$是平凡依赖，即$\beta \subseteq \alpha$
  - $\alpha$是模式R的一个超码

#### 如何去分解不属于BCNF的模式？

- 不妨假设存在至少一个非平凡的函数依赖$\alpha \rightarrow \beta$，其中$\alpha$不是R的超码，我们将其分解为
  - $(\alpha \cup \beta)$
  - $R-(\beta -\alpha)$
- 递归分解



### 一些BCNF分解不能保持依赖

- 但是我们希望能够保持依赖：（



### 2NF

- 只有历史意义，不再使用了

### 第三范式3NF

- 比BCNF弱，允许我们保持依赖

#### 哪些关系模式R属于3NF

- 满足BCNF

- **或者** 
  $$
  对于\beta - \alpha 的每一个属性A\\
  A\subseteq “关系模式R的候选码”
  $$

- **注意**，属性A可以包含于**不同**候选码

### 更高的范式【更垃圾的范式】

- 这样的范式并不是基于函数依赖【也可以看出BCNF，1NF，3NF都是基于函数依赖】
- 所以定义了其他的依赖和范式【见**使用多值依赖的分解**】



## 4函数依赖理论

### 函数依赖集的闭包

#### 逻辑蕴含是什么？

- 给定关系模式r(R),如果r(R)的每一个满足F的实例都满足f，则R上的函数依赖f被r上的r上的函数依赖**集**F逻辑蕴含。
- 【即，可以通过函数依赖**集**F可推出f】

#### 函数依赖集F的闭包是什么？

- 是被F逻辑蕴含的所有函数依赖的集合，记作$F^+$

#### Armstron公理

- 自反律
- 增补律
- 传递律

##### Armstron公理引理

- 合并律
- 分解律
- 伪传递律





### 属性集的闭包

#### 函数确定

$$
若【属性集】a\rightarrow 【属性】B , 我们称属性B被a【函数确定】
$$

#### 如何判断属性集a是否超码

- 一种方法是计算$F^+$，找出所有左半部为$a$的函数依赖，合并这些函数依赖的右半部分，**开销大**
- 使用闭包 ，检查$a^+$是否包含R中的所有属性

#### 属性闭包$a^+$

$$
F下的a的闭包：函数依赖集F下被a函数确定的所有属性的集合\\
即 \{ B| a\rightarrow B ，使用F\}
$$



### 正则覆盖

#### 无关属性

- 去除函数依赖中的一个属性不改变该属性依赖集的闭包，则称该属性是无关的

- 形式化定义：考虑函数依赖集F以及F中的函数依赖$a\rightarrow \beta$
  $$
  如果A\in a 并且F逻辑蕴含(F-\{ a\rightarrow \beta\})\cup \{ (a-A)\rightarrow \beta\},则称属性A在a中是无关的\\
  如果A\in \beta 并且函数依赖集F^{'}\{F-\{ a\rightarrow \beta \}\}\cup \{a\rightarrow (\beta - A)\}逻辑蕴含F，则称属性A在\beta 中是无关的
  $$



#### 检验属性是否无关

- 若$A\in \beta$，计算$F^{'}$下的$a^+$,若$a^+$包含A，则A在$\beta$中是无关的
- 若$A\in a$ ，令$\gamma = \alpha -\{A\}$，若F能推出$\gamma \rightarrow \beta$则称A在a中是无关的
- **目测**

#### 正则覆盖依赖集$F_c$

- 【理解为精简后的$F$】

正则覆盖集$F_c$需要满足以下条件

1. $F逻辑蕴含F_c，且 ，F_c 逻辑蕴含F$ 也就是说$F_c^{+}= F^+$
2. $F_c$中的函数依赖都不含无关属性
3. $F_c$中的函数依赖的左半部都是唯一的

#### 如何计算正则覆盖集$F_c$

1. 合并左边相同的属性集【增补律】
2. 去除无关属性
3. 可得正则覆盖

- 例

  ![屏幕截图 2020-10-28 204652](https://i.loli.net/2020/10/28/xcJyZh1YP4AIaf3.png)





### 无损分解

#### 什么是无损分解？

- R分解为两个模式A和B，用A和B替代R的时候没有信息损失，称该分解是无损分解

- 更为形式化的：对于所有合法的数据库实例，当关系r包含与下述SQL查询结果相同的元组集

  ```sql
  select *
  from (
  	(select A from R)
  	natural join
  	(select B from R)
  );
  ```

- 





### 保持依赖

#### 为什么要保持依赖？

- 保证分解后的关系模式和原关系模式等价，我们要判定
  - 分解后的关系模式是否可以无损连接
  - 是否保持依赖
- [对于二者的讲解](https://blog.csdn.net/legendaryhaha/article/details/80649234)

#### 限定

$$
F在R_i上的限定是F^+中的所有只包含R_i属性的函数依赖的集合F_i\\
$$

#### 保持依赖的分解

##### 充分条件【指数时间】

$$
设有F^{'}=F_1\cup F_2\cup F_3...\cup F_n\\
我们称具有性质F^{'+}=F^+的分解为保持依赖的分解\\
$$

##### 充分必要条件【多项式时间】

- 对于F中的每一个a->b

  ![屏幕截图 2020-10-28 210000](https://i.loli.net/2020/10/28/YhRFMSq8m6AIlCs.png)

- 这里的属性闭包是在F下，假如result包含b的所有属性，那么a->b保持依赖。

## 分解算法

















# 其他

- 属性集$\alpha$
- 关系模式$r(R)$
- 超码$K$
- 



## 表达一致性约束的方式

### 主码约束

### 函数依赖

### check约束

### 断言

### 触发器



## 多值属性

- 多值属性的每一个属性对应一个模式



- 正则覆盖不一定唯一





### 原子性

### 一致性

### 持久性






















- 用户创建

```sql
create user c##Xxgzbd identified by Orcl1234;
```



# 表

- 创建表

  ```sql
  create table table_name(
  	Field_name type 	
      constraint PK_name primary key (Field_name)
  );
  ```

```sql
example
create table locations(
	lid char(4) not null,
    city varchar2(20) not null,
    address varchar2(100) not null,
    
    postcode char(6) null,
    constraint locations_lid_pk primary key(lid)
);
```



```
//Q: what is difference between varchar2 and varchar :
varchar2 使得 ''变为NULL
...
```





## delete 

- 删除元组

```
delete from table_name 
where [谓词]
```

```sql
//example1
delete from locations
where lid in ('1');
//example2
delete from locations
where lid not in (select lid from locations);
```

- ```sql
  delete from student;//删除所有元组
  ```



## drop

- 删除关系

- ```
  drop table r
  ```

  



## alter

- 修改属性

- ```sql
  alter table r add A D;//增加新属性A
  ```

- ```sql
  alter table r drop A;//去掉属性A
  ```



- 



## 查询

```sql
select name
from instructor
```



```sql
select name
from instructor
where dept_name = 'Comp. Sci.' and salary > 70000;//带条件查询
```





```sql
create table department
(dept_name varchar(20),
building varchar (15) ,
budget numeric (12 ,2) ,
primary key (dept_name)) ;

```





```sql
create table course
(course_id varchar (7) ,
title varchar (50) ,//课程名字
dept_name varchar (20),
credits numeric (2,0),
primary key (course_id),
foreign key (dept_name) references department) ;
```



```sql
create table instructor
(ID varchar (5) ,
name varchar (20) not null,
dept_name varchar (20) ,
salary numeric (8,2),
primary key (ID) ,
foreign key (dept_name) references department);
```



```sql
create table section
(
course_id varchar (8) ,
sec_id varchar (8) ,
semester varchar (6) ,
year numeric (4,0),
building varchar (15) ,
room_number varchar (7),
time_slot_id varchar (4) ,
primary key (course_id，sec_id, semester，year),
foreign key (course_id) references course
) ;
```

```sql
create table teaches
(
    ID varchar(5),//教师ID
    course_id varchar (8) ,//课程ID
    sec_id varchar (8) ,
    semester varchar(6),
    year numeric (4,0),
    primary key (ID, course_id, sec_id,semester,year),
    foreign key ( course_id,sec_id,semester,year ) references section,
    foreign key (ID) references instructor
);
```

```sql
select dept_name, count (distinct id) as instr_count
from instructor natural join teaches
where semester = 'Spring' and year =2010
group by dept_name;
```

- 

```sql
create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
```



- create

```
create table classroom
	(building		varchar(15),
	 room_number		varchar(7),
	 capacity		numeric(4,0),
	 primary key (building, room_number)
	);
 
create table department
	(dept_name		varchar(20), 
	 building		varchar(15), 
	 budget		        numeric(12,2) check (budget > 0),
	 primary key (dept_name)
	);
 
create table course
	(course_id		varchar(8), 
	 title			varchar(50), 
	 dept_name		varchar(20),
	 credits		numeric(2,0) check (credits > 0),
	 primary key (course_id),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table instructor
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 salary			numeric(8,2) check (salary > 29000),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table section
	(course_id		varchar(8), 
         sec_id			varchar(8),
	 semester		varchar(6)
		check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), 
	 year			numeric(4,0) check (year > 1701 and year < 2100), 
	 building		varchar(15),
	 room_number		varchar(7),
	 time_slot_id		varchar(4),
	 primary key (course_id, sec_id, semester, year),
	 foreign key (course_id) references course
		on delete cascade,
	 foreign key (building, room_number) references classroom
		on delete set null
	);
 
create table teaches
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id,sec_id, semester, year) references section
		on delete cascade,
	 foreign key (ID) references instructor
		on delete cascade
	);
 
create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table takes
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 grade		        varchar(2),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id,sec_id, semester, year) references section
		on delete cascade,
	 foreign key (ID) references student
		on delete cascade
	);
 
create table advisor
	(s_ID			varchar(5),
	 i_ID			varchar(5),
	 primary key (s_ID),
	 foreign key (i_ID) references instructor (ID)
		on delete set null,
	 foreign key (s_ID) references student (ID)
		on delete cascade
	);
 
create table time_slot
	(time_slot_id		varchar(4),
	 day			varchar(1),
	 start_hr		numeric(2) check (start_hr >= 0 and start_hr < 24),
	 start_min		numeric(2) check (start_min >= 0 and start_min < 60),
	 end_hr			numeric(2) check (end_hr >= 0 and end_hr < 24),
	 end_min		numeric(2) check (end_min >= 0 and end_min < 60),
	 primary key (time_slot_id, day, start_hr, start_min)
	);
 
create table prereq
	(course_id		varchar(8), 
	 prereq_id		varchar(8),
	 primary key (course_id, prereq_id),
	 foreign key (course_id) references course
		on delete cascade,
	 foreign key (prereq_id) references course
	);
 
```







```
select max(tot_salary)
 from (select dept_name,sum(salary) as tot_salary
from instructor
  group by dept_name )
   dept_total ;
```











- `with`

```sql
with max_budget (value) 
as (select max(budget)
from department)
select budget
from department,max_budget
where department.budget = max_budget.value;
```



```sql
with 
dept_total(dept_name,value)as
(select dept_name,sum (salary)
 from instructor
 group by dept_name),
dept_total_avg (value) as
(select avg(value)
from dept_total)
select dept_name
from dept_total,dept_total_avg
where dept_total.value >=dept_total_avg.value;
```

- 标量子查询

```
select dept_name,
(
select count(*)
from instructor
where department.dept_name = instructor.dept_name
)
as num_instructors
from department;
```



- ```
  
  SQL> create view physics_fall_2009 as
  select course.course_id,sec_id,building,room_number
     from course,section
      where
      course.course_id = section.course_id
      and course.dept_name = 'Physics'
      and section.semester ='Fall'
      and section.year = '2009'
      ;
  ```

  



- ```sql
  date'2001-04-25'
  time'09: 30: 00'
  timestamp'2001-04-2510:29:01.45'
  ```

  





# 一些语句

- 请用 SQL语句中的select子句表达：统计各个学院内老师的数量。

  ```
  select dept_name ,(
  select count(*) 
  from instructor 
  where department.dept_name = instructor.dept_name
  ) as num_instructors
  from department;
  ```

- 找到选了生物学院所有开设的课程的学生

  ```
  select distinct S.id,S.name
  from student as S
  where not exists (
  	(
  		select course_id
  		from course
  		where dept_name ='Biology'
  	)except(
  		select T.course_id
  		from takes as T
  		where S.ID = T.ID
  	)
  )
  ```

  





- 写一个过程*dept_count_proc*，计算某一学院的教师数量。输入形参为学院的名字。

  ```sql
  create procedure dept_count_proc (in dept_name varchar(20),out d_count integer)
  begin
  	select count(*)into d_count
  	from instructor
  	where instructor.dept_name = dept_count_proc.dept_name
  end;
  ```

  