# 0x01

文件处理系统中存储组织信息的弊端

- data redundancy and inconsistency 数据冗余和不一致（重复，并且不一致）
- difficulty in accessing data 数据访问困难（索引困难）
- data isolation 数据孤立（不同文件，不同格式）
- integrity problem 完整性问题（难以满足新的约束）
- atomicity problem 原子性问题
- concurrent - access anomaly 并发访问异常（文件互斥访问过于束缚）
- security problem 安全性问题

数据库是在文件的基础上发展的



数据库的层次

- physical level 物理层，如何存储
- logical level 逻辑层，确定数据库中需要存储什么信息
- view level 视图层，隐藏部分数据，用户所看到的是这些视图

![数据抽象的3个层次](https://i.loli.net/2020/08/26/BtgSU9Zwr6WnIpM.png)



- Schema 模式，相当于程序设计语言中的变量
  - Physical schema 物理模式
  - Logical schema 逻辑模式
- Instance 实例，相当于程序设计语言的值
- data model 数据模型，一个描述数据，数据联系，数据语义以及一致性约束的概念工具的集合
  - Relational Model 关系模型
  - ER,entity-relationship Model 实体关系模型
  - Object-based data models 基于对象的数据模型
  - Semistructured data model 半结构化数据模型 (XML)
  - Other older models(很老了现在不再使用)
    - Network Model 网状数据模型
    - Hierarchical model 层次数据模型



##### 数据库语言

- Data-Manipulation Language DML 数据操纵语言
- Data-Definition Language DDL 数据定义语言





##### Users 用户

- Application programmers 使用DML来访问
- Sophisticated users 直接使用数据库查询语言
- Specialized users 完全不同（
- Naive users 最简单
- DBA，Database Administrator 数据库管理员

![系统体系结构](https://i.loli.net/2020/08/26/Imyf1hiA8aKCBXD.png)









# 3

## 2

### 基本类型

##### char(n)  固定长度的字符串，用户指定长度n

##### varchar(n)   可变长度的字符串，用户指定最大长度n

##### int   整数

##### smallint  小整数

##### numeric(p,d)    定点数  

- p位数字
- d位数字在小数点右边
- 1位符号位

##### real,double precision   浮点数和双精度浮点数

##### float(n)   精度至少为n位的浮点数





# 8关系数据库设计

## 1好的关系设计的特点

### 1更大的模式

- 带来的问题：导致存在大量的空值

### 2更小的模式

- 带来的问题：有损分解

#### 函数依赖是什么？

- 存在这样的一条规则，如果存在模式(dept_name,budget)，则dept_name 可以作为主码，这条规则定义为函数依赖。记作
  $$
  dept\_ name \rightarrow budget
  $$

#### 有损分解

- 不仅仅是元组的丢失，元组的增加也能称之为有损分解

#### 无损分解

- 反之

## 2原子域和第一范式

### 什么域是原子域？

- 一个域是原子的，假如该域的**元素**被认为是不可分的单元。

### 什么样的关系模式R属于第一范式

- 如果R的所有属性的域都是原子的，那么我们称R属于第一范式。

### 是否原子只需要满足数据库的设计即可，没有必要一定说明可拆分就是非原子

## 3使用函数依赖进行分解

### 码和函数依赖

#### 关系的合法实例

- 一个关系的满足所有这种现实世界约束的实例称之为关系的合法实例。

- 常用的现实世界约束形式化表示为**码**



- 一个实例满足**函数依赖**$\alpha \rightarrow \beta$的条件是：对于实例中的**所有**元组对$t_1$和$t_2$，若$t_1[\alpha]=t_2[\beta]$，则$t_1[\beta]=t_2[\beta]$
- 如果r(R)的每个合法实例都满足**函数依赖**，则我们说该函数依赖在模式r(R)上是**成立**的
- 值得注意的是一个实例满足（现实世界中的一个合法实例），并不代表现实世界中的所有实例都满足。



#### 平凡依赖

- 如果$\beta \subseteq  \alpha$，则$\alpha \rightarrow \beta$这样的依赖称之为平凡依赖



#### 函数依赖集F的闭包

- F的闭包是 能从F集合中推导出的所有函数依赖的集合，称之为$F^+$



### Boyce-Codd范式 BCNF

- 它能消除所有基于函数依赖能发现的冗余

#### 哪些关系模式R属于BCNF？

- 具有函数函数依赖集合F的关系模式R属于BCNF的条件，对于$F^+$中的所有形如$\alpha \rightarrow \beta$的函数依赖，至少成立一项
  - $\alpha \rightarrow \beta$是平凡依赖，即$\beta \subseteq \alpha$
  - $\alpha$是模式R的一个超码

#### 如何去分解不属于BCNF的模式？

- 不妨假设存在至少一个非平凡的函数依赖$\alpha \rightarrow \beta$，其中$\alpha$不是R的超码，我们将其分解为
  - $(\alpha \cup \beta)$
  - $R-(\beta -\alpha)$
- 递归分解



### 一些BCNF分解不能保持依赖

- 但是我们希望能够保持依赖：（



### 2NF

- 只有历史意义，不再使用了

### 第三范式3NF

- 比BCNF弱，允许我们保持依赖

#### 哪些关系模式R属于3NF

- 满足BCNF

- **或者** 
  $$
  对于\beta - \alpha 的每一个属性A\\
  A\subseteq “关系模式R的候选码”
  $$

- **注意**，属性A可以包含于**不同**候选码

### 更高的范式【更垃圾的范式】

- 这样的范式并不是基于函数依赖【也可以看出BCNF，1NF，3NF都是基于函数依赖】
- 所以定义了其他的依赖和范式【见**使用多值依赖的分解**】



## 4函数依赖理论

### 函数依赖集的闭包

#### 逻辑蕴含是什么？

- 给定关系模式r(R),如果r(R)的每一个满足F的实例都满足f，则R上的函数依赖f被r上的r上的函数依赖**集**F逻辑蕴含。
- 【即，可以通过函数依赖**集**F可推出f】

#### 函数依赖集F的闭包是什么？

- 是被F逻辑蕴含的所有函数依赖的集合，记作$F^+$

#### Armstron公理

- 自反律
- 增补律
- 传递律

##### Armstron公理引理

- 合并律
- 分解律
- 伪传递律





### 属性集的闭包

#### 函数确定

$$
若【属性集】a\rightarrow 【属性】B , 我们称属性B被a【函数确定】
$$

#### 如何判断属性集a是否超码

- 一种方法是计算$F^+$，找出所有左半部为$a$的函数依赖，合并这些函数依赖的右半部分，**开销大**
- 使用闭包 ，检查$a^+$是否包含R中的所有属性

#### 属性闭包$a^+$

$$
F下的a的闭包：函数依赖集F下被a函数确定的所有属性的集合\\
即 \{ B| a\rightarrow B ，使用F\}
$$



### 正则覆盖

#### 无关属性

- 去除函数依赖中的一个属性不改变该属性依赖集的闭包，则称该属性是无关的

- 形式化定义：考虑函数依赖集F以及F中的函数依赖$a\rightarrow \beta$
  $$
  如果A\in a 并且F逻辑蕴含(F-\{ a\rightarrow \beta\})\cup \{ (a-A)\rightarrow \beta\},则称属性A在a中是无关的\\
  如果A\in \beta 并且函数依赖集F^{'}\{F-\{ a\rightarrow \beta \}\}\cup \{a\rightarrow (\beta - A)\}逻辑蕴含F，则称属性A在\beta 中是无关的
  $$



#### 检验属性是否无关

- 若$A\in \beta$，计算$F^{'}$下的$a^+$,若$a^+$包含A，则A在$\beta$中是无关的
- 若$A\in a$ ，令$\gamma = \alpha -\{A\}$，若F能推出$\gamma \rightarrow \beta$则称A在a中是无关的
- **目测**

#### 正则覆盖依赖集$F_c$

- 【理解为精简后的$F$】

正则覆盖集$F_c$需要满足以下条件

1. $F逻辑蕴含F_c，且 ，F_c 逻辑蕴含F$ 也就是说$F_c^{+}= F^+$
2. $F_c$中的函数依赖都不含无关属性
3. $F_c$中的函数依赖的左半部都是唯一的

#### 如何计算正则覆盖集$F_c$

1. 合并左边相同的属性集【增补律】
2. 去除无关属性
3. 可得正则覆盖

- 例

  ![屏幕截图 2020-10-28 204652](https://i.loli.net/2020/10/28/xcJyZh1YP4AIaf3.png)





### 无损分解

#### 什么是无损分解？

- R分解为两个模式A和B，用A和B替代R的时候没有信息损失，称该分解是无损分解

- 更为形式化的：对于所有合法的数据库实例，当关系r包含与下述SQL查询结果相同的元组集

  ```sql
  select *
  from (
  	(select A from R)
  	natural join
  	(select B from R)
  );
  ```

- 





### 保持依赖

#### 为什么要保持依赖？

- 保证分解后的关系模式和原关系模式等价，我们要判定
  - 分解后的关系模式是否可以无损连接
  - 是否保持依赖
- [对于二者的讲解](https://blog.csdn.net/legendaryhaha/article/details/80649234)

#### 限定

$$
F在R_i上的限定是F^+中的所有只包含R_i属性的函数依赖的集合F_i\\
$$

#### 保持依赖的分解

##### 充分条件【指数时间】

$$
设有F^{'}=F_1\cup F_2\cup F_3...\cup F_n\\
我们称具有性质F^{'+}=F^+的分解为保持依赖的分解\\
$$

##### 充分必要条件【多项式时间】

- 对于F中的每一个a->b

  ![屏幕截图 2020-10-28 210000](https://i.loli.net/2020/10/28/YhRFMSq8m6AIlCs.png)

- 这里的属性闭包是在F下，假如result包含b的所有属性，那么a->b保持依赖。

## 分解算法

















# 其他

- 属性集$\alpha$
- 关系模式$r(R)$
- 超码$K$
- 



## 表达一致性约束的方式

### 主码约束

### 函数依赖

### check约束

### 断言

### 触发器



## 多值属性

- 多值属性的每一个属性对应一个模式



- 正则覆盖不一定唯一




























- 用户创建

```sql
create user c##Xxgzbd identified by Orcl1234;
```



# 表

- 创建表

  ```sql
  create table table_name(
  	Field_name type 	
      constraint PK_name primary key (Field_name)
  );
  ```

```sql
example
create table locations(
	lid char(4) not null,
    city varchar2(20) not null,
    address varchar2(100) not null,
    
    postcode char(6) null,
    constraint locations_lid_pk primary key(lid)
);
```



```
//Q: what is difference between varchar2 and varchar :
varchar2 使得 ''变为NULL
...
```





## delete 

- 删除元组

```
delete from table_name 
where [谓词]
```

```sql
//example1
delete from locations
where lid in ('1');
//example2
delete from locations
where lid not in (select lid from locations);
```

- ```sql
  delete from student;//删除所有元组
  ```



## drop

- 删除关系

- ```
  drop table r
  ```

  



## alter

- 修改属性

- ```sql
  alter table r add A D;//增加新属性A
  ```

- ```sql
  alter table r drop A;//去掉属性A
  ```



- 



## 查询

```sql
select name
from instructor
```



```sql
select name
from instructor
where dept_name = 'Comp. Sci.' and salary > 70000;//带条件查询
```





```sql
create table department
(dept_name varchar(20),
building varchar (15) ,
budget numeric (12 ,2) ,
primary key (dept_name)) ;

```





```sql
create table course
(course_id varchar (7) ,
title varchar (50) ,//课程名字
dept_name varchar (20),
credits numeric (2,0),
primary key (course_id),
foreign key (dept_name) references department) ;
```



```sql
create table instructor
(ID varchar (5) ,
name varchar (20) not null,
dept_name varchar (20) ,
salary numeric (8,2),
primary key (ID) ,
foreign key (dept_name) references department);
```



```sql
create table section
(
course_id varchar (8) ,
sec_id varchar (8) ,
semester varchar (6) ,
year numeric (4,0),
building varchar (15) ,
room_number varchar (7),
time_slot_id varchar (4) ,
primary key (course_id，sec_id, semester，year),
foreign key (course_id) references course
) ;
```

```sql
create table teaches
(
    ID varchar(5),//教师ID
    course_id varchar (8) ,//课程ID
    sec_id varchar (8) ,
    semester varchar(6),
    year numeric (4,0),
    primary key (ID, course_id, sec_id,semester,year),
    foreign key ( course_id,sec_id,semester,year ) references section,
    foreign key (ID) references instructor
);
```

```sql
select dept_name, count (distinct id) as instr_count
from instructor natural join teaches
where semester = 'Spring' and year =2010
group by dept_name;
```

- 

```sql
create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
```



- create

```
create table classroom
	(building		varchar(15),
	 room_number		varchar(7),
	 capacity		numeric(4,0),
	 primary key (building, room_number)
	);
 
create table department
	(dept_name		varchar(20), 
	 building		varchar(15), 
	 budget		        numeric(12,2) check (budget > 0),
	 primary key (dept_name)
	);
 
create table course
	(course_id		varchar(8), 
	 title			varchar(50), 
	 dept_name		varchar(20),
	 credits		numeric(2,0) check (credits > 0),
	 primary key (course_id),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table instructor
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 salary			numeric(8,2) check (salary > 29000),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table section
	(course_id		varchar(8), 
         sec_id			varchar(8),
	 semester		varchar(6)
		check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), 
	 year			numeric(4,0) check (year > 1701 and year < 2100), 
	 building		varchar(15),
	 room_number		varchar(7),
	 time_slot_id		varchar(4),
	 primary key (course_id, sec_id, semester, year),
	 foreign key (course_id) references course
		on delete cascade,
	 foreign key (building, room_number) references classroom
		on delete set null
	);
 
create table teaches
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id,sec_id, semester, year) references section
		on delete cascade,
	 foreign key (ID) references instructor
		on delete cascade
	);
 
create table student
	(ID			varchar(5), 
	 name			varchar(20) not null, 
	 dept_name		varchar(20), 
	 tot_cred		numeric(3,0) check (tot_cred >= 0),
	 primary key (ID),
	 foreign key (dept_name) references department
		on delete set null
	);
 
create table takes
	(ID			varchar(5), 
	 course_id		varchar(8),
	 sec_id			varchar(8), 
	 semester		varchar(6),
	 year			numeric(4,0),
	 grade		        varchar(2),
	 primary key (ID, course_id, sec_id, semester, year),
	 foreign key (course_id,sec_id, semester, year) references section
		on delete cascade,
	 foreign key (ID) references student
		on delete cascade
	);
 
create table advisor
	(s_ID			varchar(5),
	 i_ID			varchar(5),
	 primary key (s_ID),
	 foreign key (i_ID) references instructor (ID)
		on delete set null,
	 foreign key (s_ID) references student (ID)
		on delete cascade
	);
 
create table time_slot
	(time_slot_id		varchar(4),
	 day			varchar(1),
	 start_hr		numeric(2) check (start_hr >= 0 and start_hr < 24),
	 start_min		numeric(2) check (start_min >= 0 and start_min < 60),
	 end_hr			numeric(2) check (end_hr >= 0 and end_hr < 24),
	 end_min		numeric(2) check (end_min >= 0 and end_min < 60),
	 primary key (time_slot_id, day, start_hr, start_min)
	);
 
create table prereq
	(course_id		varchar(8), 
	 prereq_id		varchar(8),
	 primary key (course_id, prereq_id),
	 foreign key (course_id) references course
		on delete cascade,
	 foreign key (prereq_id) references course
	);
 
```







```
select max(tot_salary)
 from (select dept_name,sum(salary) as tot_salary
from instructor
  group by dept_name )
   dept_total ;
```











- `with`

```sql
with max_budget (value) 
as (select max(budget)
from department)
select budget
from department,max_budget
where department.budget = max_budget.value;
```



```sql
with 
dept_total(dept_name,value)as
(select dept_name,sum (salary)
 from instructor
 group by dept_name),
dept_total_avg (value) as
(select avg(value)
from dept_total)
select dept_name
from dept_total,dept_total_avg
where dept_total.value >=dept_total_avg.value;
```

- 标量子查询

```
select dept_name,
(
select count(*)
from instructor
where department.dept_name = instructor.dept_name
)
as num_instructors
from department;
```



- ```
  
  SQL> create view physics_fall_2009 as
  select course.course_id,sec_id,building,room_number
     from course,section
      where
      course.course_id = section.course_id
      and course.dept_name = 'Physics'
      and section.semester ='Fall'
      and section.year = '2009'
      ;
  ```

  



- ```sql
  date'2001-04-25'
  time'09: 30: 00'
  timestamp'2001-04-2510:29:01.45'
  ```

  





# 一些语句

- 请用 SQL语句中的select子句表达：统计各个学院内老师的数量。

  ```
  select dept_name ,(
  select count(*) 
  from instructor 
  where department.dept_name = instructor.dept_name
  ) as num_instructors
  from department;
  ```

- 找到选了生物学院所有开设的课程的学生

  ```
  select distinct S.id,S.name
  from student as S
  where not exists (
  	(
  		select course_id
  		from course
  		where dept_name ='Biology'
  	)except(
  		select T.course_id
  		from takes as T
  		where S.ID = T.ID
  	)
  )
  ```

  





- 写一个过程*dept_count_proc*，计算某一学院的教师数量。输入形参为学院的名字。

  ```sql
  create procedure dept_count_proc (in dept_name varchar(20),out d_count integer)
  begin
  	select count(*)into d_count
  	from instructor
  	where instructor.dept_name = dept_count_proc.dept_name
  end;
  ```

  