



#### 中间代码的生成

###### 中间代码生成的几个问题

- 操作分量或运算结果的地址表示为
  1. 标号类
  2. 数值类
  3. 地址类
- 语义栈`Sem`
  - `push(x)` 将`x`的类型和语义信息压入`Sem`栈中
  - `pop(n)` 将`Sem`栈顶的n个元素弹栈
  - `new_dir(t)` 在临时变量区申请一个t，且t是直接寻址
  - `new_indir(t)` 在临时变量区申请一个t，且t是间接寻址
  - `Generate(w,left,right,result)` 
  - `GenCode(w)`



- 其中

  - 对于临时变量的层数取-1

  

###### 表达式的中间代码生成

- 定义表达式的`LL(1)`文法

  ![算术表达式的LL1文法定义](https://i.loli.net/2020/10/14/63UfCaBut5lIqLE.png)

![屏幕截图 2020-10-14 162734](https://i.loli.net/2020/10/14/qUVofvhlNejZ78Q.png)

- 当遇到常量C和简单变狱id时， 把它们的语义信息压入语义栈（产生式9) 和
  10))。
- 当处理完一个运算符（＋、－、＊ 、／）的右分蜇时， 该运算符的左、右运算分量
  已经分别存放在语义栈`Sem`的次栈顶和栈顶的位置， 因此可以生成相应的运算符的四元式，
  并把运算结果的语义信息压入语义栈（产生式3) 、4)、7)和8))。







# 9运行时存储空间的组织与管理



## 目标代码运行时的存储结构

### 目标代码运行时的内存的划分

- 其中， 

#### 库代码空间

#### 目标代码空间

#### 静态区空间

#### 栈区空间

#### 堆区空间

- 动态申请和释放的内存



#### 这些空间是在什么时候分配的？

- 代码区和静态区空间是在编译时分配的， 栈区空间和堆区空间是在运行时分配的。



#### 如何计算变量的实际地址？

- 许多目标机的目标代码中常常用一个专门的**寄存器**来记录**栈顶**的值， 这个寄存器则被命名为top。若变址x相对栈顶top 的偏移扯记为Offsetx, 则变社x 的内存地址是**top-Offsetx**。
- 有的目标机用两个寄存器分别表示栈底和栈顶的值， 分别记为**sp** 和**top**。此时， 变址的偏移址都是相对栈底sp而言的， 假设变址y 的偏移是Offsety, 则变址的内存地址是**sp +Offsety**。

![image-20201103150835034](https://i.loli.net/2020/11/03/nINqGFOa6ZKtW5P.png)



#### EG  C语言代码对应运行时内存示意图

- 注意：是运行时

![image-20201103150911331](https://i.loli.net/2020/11/03/HMUlLPJKsA36WcX.png)

### 目标程序运行时的存储分配策略

#### 有哪些存储分配策略？

##### 动态存储分配策略

- 动态存储分配策略又可分为栈式动态存储分配策略和堆式动态存储分配策略。

###### 栈式动态存储分配策略

###### 堆式动态存储分配策略

##### 静态存储分配策略



#### 什么是静态分配策略？

- 在编译时间为所有数据对象分配**固定**的存储单元
- 在运行时间保待不变



#### 存储空间分配的本质是什么？

- 将程序中每个变量名字与一个存储位置关联起来，·该存储位置用以容纳该变量的值。

#### 影响存储分配策略的语言特征

- 过程能否**递归**。
- 当控制从过程的活动返回时，局部变量的值是否要保留。
-  过程能否访问非局部变量。
- 过程调用的参数传递方式。
-  过程能否作为参数被传递。
- 过程能否作为结果值传递。
-  存储块能否在程序控制下动态地分配。
- 存储块是否必须显式地释放。



#### 静态存储分配策略

- 每个过程活动记录大小必须是固定

##### 静态存储分配策略的约束条件

- 不允许递归过程，因为一个过程的所有活动使用同一个活动记录
- 不允许可变体积的数据
- 不允许动态建立数据结构【指针，动态数组】

#### 栈式动态存储分配策略

##### 为什么无法确定每一个活动记录的起始地址和每一个活动记录中数据的绝对地址？

- 每个过程活动记录都是根据目标代码的执行情况动态分配的。但是可以确定在活动记录中的相对位置【偏移量】

##### 栈式分配策略可以解决哪些问题？

- 递归调用问题
- 空间共享的问题

#### 堆式动态存储分配策略

##### 为什么要堆式动态存储分配策略？

- 程序设计语言允许用户自由地申请和释放数据空间， 即空间的使用未必服从“ 先申请后释放， 后申请先释放” 的原则

##### 缺点

- 实现代价大

## 过程活动记录和运行时栈

### 过程活动记录

#### 什么是过程活动记录AR Activation Record

- 给被调用过程分配一段**连续**的存储空间，以便存放 该过程的局部变扯值、保存中间结果的临时变址、过程调用的控制信息等内容。

#### 过程活动记录的域有哪些？

- 动态链指针，用来指向**调用者**的活动记录的起始地址， 即老sp。
- 返回地址，指向 **调用者过程**调用指令对应的目标代码的**下一条目标指令**
- 返回值，调用者中用于**存放返回值**的临时变量的地址
- 寄存器状态，即**中断现场**
- 过程层数，用于程序非正常出口情形处理，一般不用记录
- 活动记录空间大小，用于过程调用返回时返回到**指定地址**。
- 变量访问环境，构造非局部数据访问环境，如Display 表，静态链指针
- 形参变量区，用于存放**调用过程**向**被调用过程**提供的实在参数。
- 局部变量区，保存过程局部声明的数据。
- 临时变量区

#### top寄存器的作用是什么？

- 用于指向当前活动记录的最新**可分配**地址的专用寄存器
- top-sp即为**活动记录空间的大小**，因此，只要top寄存器与”活动记录空间大小＂ 域中有一个即可。

#### 什么信息不在过程活动记录中？

- 非局部数据
- 运行时生成的动态变量



### 过程活动记录的申请和释放

#### 调用链

##### 什么是调用链？

- 调用链是以主程序名M为首部的**过程名的序列**

- 更详细的：

  - 若`(M....R)`是调用链
  - 并且R中有S的调用
  - 那么`(M.....R,S)`是调用链

- 我们使用
  $$
  CallChain(S) = (M,...,R,S)
  $$
  来表示S的调用链，其中S是正在执行的过程体，`M...R`是已经执行但是被中断的过程

- 调用链并不是唯一的【动态的】



#### 动态链

##### 什么是动态链？

- 动态链式过程活动记录AR的序列，这个序列和调用链相对应。

- 用于恢复**调用者**的AR

- S的动态链形式化定义为
  $$
  DynamicChains(S) = [AR(M),...,AR(R),AR(S)]
  $$
  

![image-20201103170236418](https://i.loli.net/2020/11/03/WN7EaHcPfFrliAX.png)

#### 活动记录的空间的分配和释放

##### 分配的时候做了什么？

- 在翻译(CALL, f, true , t) 时， 需要做以下工作：
  • 将t (返回值应存放的变址） 的地址存放到返回值单元。
  • 把sp 的值放到动态链地址单元。
  • 填写过程层数信息。
  • 保存返回地址。
  • 保存变址访问环境（必要的情况下）。
  • 保存AR 长度size。
  • 改变sp 的值。
  • 转向f的入口地址。

##### 释放的时候做了什么？

- 恢复寄存器。
- 改变sp的值，sp = 动态链地址空间存的值。
- 转向返回地址对应的代码执行。





## 变量访问环境



### 声明链

- 声明链是以主程序名M为首的过程名序列

- 具体定义为：若`(M,.....P)`是声明链

- 若P中有过程Q的声明，那么`(M,..R,Q)`是Q的声明链

- $$
  DeclaChain(Q) = (M,...P,Q)
  $$

- 对于任一过程Q，它的声明链是**唯一**的，并且在Q中出现的变量，其声明一定在DeclaChain(Q)中



### 变量访问环境

##### 什么是活跃活动记录LAR(S)

- 一个过程S在动态链中可有多个AR, 其中， 只有最新的AR(S)是可访问的，称可访问的AR(S)是LAR(S)

##### 什么是变量访问环境

- Q的声明链【DeclaChain(Q)】中的每个过程的活跃活动记录构成的链称为Q的当前变最访问环境
  $$
  VarVisitEnv(LAR(Q) ) = [LAR(M), …, LAR(P), LAR(Q)]
  $$
  



##### 如何表示变量的存储单元地址？

- 若有一个变量X在过程Q中。

- 那么X的存储单元地址为

- $$
  addr(X) = <LAR(Q)> + Offset_X
  $$





##### 如何实现变量访问环境【VarVisitEnv(LAR(Q) )】

###### Display 表方法

- 其中有全局Display 表【不细说】和局部Display表

###### 静态链方法



### Display表方法

#### 局部Display表方法

##### 什么是Display表？

- 对于每个**AR**引入一个**指针数组**，称为Display表， 每进入一个过程，在为它建立的活动记录区中增加一段连续的单元，用于存放它的**Display表**。
- 假定进入过程的层数为**L**, 则它的Display表含有**L+ 1**个单元。这L+ 1个单元自顶向下每个单元依次存放着现行层(L层），直接外层(L-1层），…，直至最外层(0层，主程序层） 的**每一层过程**的最新**活动记录的起始地址**。‘
- 换句话来说，Display表是和层数相关的【毕竟每一层也只能有一个活跃的过程活动记录】
- Display表保存在过程活动记录中

![image-20201103173213821](https://i.loli.net/2020/11/03/eiAk4sCWlEFqt8V.png)

##### Display表的大小什么时候可以确定？

- 编译时候可以确定，因为过程的层数在编译时可确定

##### 非局部量的绝对地址可表示为？

- ```
  绝对地址=Display [静态层数］＋相对地址
  ```

- eg

  ```
  LOADR l(, lnti Off + L)[ SP] / *获得第L层过程的最新活动记录地址＊／
  LOADR 2, Offsetx[ R l] I *把x的值传递给R2* /
  ```

##### Display表是如何建立的？

- 当过程P调用过程Q而进入Q后，Q如何建立其Display表【这里则使用到了动态链】

<img src="https://i.loli.net/2020/11/03/dl5fzHrgLhJRpI7.png" alt="image-20201103173549768" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/11/03/6e4HDgh12ovndFR.png" alt="image-20201103174028914" style="zoom:50%;" />

- 而对于层数的描述是指声明链的层数`level`



###### eg

- 假设有图9. 18 所示的Display 表示意图， 并且有Level(M) = 0, Level(Q) = 1, Level(R) =l, Level(S)= 2, 假设当前过程S 有变掀Xs、YQ 和ZM,其中，下标名表示变址被定义的过程名，若用Lx、Ly和Lz分别表示相应变址的层次，

- 则上述3个变址的地址分别如下：

- ```
  addr(Xs) = sp+offsetx
  addr(Yq) = (sp+InitOff)[Ly]+offsety
  addr(Zm) = (sp+InitOff)[Lz]+offsetz
  ```

#### 全局Display表法

- 略

### 静态链方法

#### 为什么要静态链方法？

- 节省空间

#### 什么是静态链指针？

- 是活动记录的一个域，指向**直接**外层过程【上一层】的最新活动记录的始地址
- 这些指针所构成的链式静态链

#### 如何填写静态链指针？

![image-20201103180249851](https://i.loli.net/2020/11/03/VA1qIdQ2XzaNnGx.png)



- ```
  当NewAr.Level > CurrentAR.Level 时，NewAR.Static = sp
  当NewAR.Level <= CurrentAR.Level 时，NewAR.Static = Indir(sp,m) ,其中m=CurrentAR.Level -NewAR.Level +1
  Indir(sp,m)表示sp的m次间接内容
  ```

  

#### 使用静态链指针的变量如何访问

```
变量X(L,off)的地址
若L = CurrentAR.Level，则addr(X) = sp+off
若L = CurrentAR.Level + 1 - k，则addr(X)=Indir(sp,k)+off
```



### 注意！

- 只有嵌套式语言才有变量访问环境的概念
- 并列式语言不需要变量访问环境

#### 指针sp

- 指向当前正在运行的过程的活动记录的基地址

#### 动态链

- 指向调用者的最新活动记录的基地址

#### 静态链指针

- 指向当前正在运行的过程的静态直接外层过程的基地址



## EG

![image-20201103181617651](https://i.loli.net/2020/11/03/l9zqFeTpKOfkc6W.png)



