# 【绪论

## 编译器

![image-20201113221147295](https://i.loli.net/2020/11/13/DlAqfHUCjBvs5PJ.png)





# 形式语言和自动机理论基础

### 字母表是什么？

- 字母表是元素的**非空**有穷集合

### 符号串是什么？

- 符号串是由字母表中的符号组成的任意有穷序列称为符号串【**可为空**】





## 文法

### 什么是文法？

- 一个文法是一个**四元组**：$(V_N,V_T,S,P)$
- $V_N$是**非空有限**的**非终极**符集合
- $V_T$是**非空有限**终极符的集合
- S是文法的开始符号
- P是**产生式**【也可以说是**规则**】的有限集合

### 文法的分类

#### 什么是语言？

- 乔姆斯基将语言形式化的定义为由一个字母表中的字符组成的**字符串集合**

#### 0型文法【短语型文法，图灵机】

#### 1型文法【上下文相关文法】

![image-20201114110556547](https://i.loli.net/2020/11/14/HQeauLxpElUns5t.png)



#### 2型文法【上下文无关文法】

- 若没有特殊说明，本文后面所描述的文法都是2型文法

![image-20201114110622041](https://i.loli.net/2020/11/14/pnvWclZRCxYPKEk.png)

#### 3型文法【线性文法，正则文法，与DFA等价】

![image-20201114110745853](https://i.loli.net/2020/11/14/yHQ9Y6qlrwoCWhv.png)

##### 正则文法和自动机之间的转换

###### 正则文法到DFA

###### DAF到正则文法

![image-20201117155830078](https://i.loli.net/2020/11/17/jG2S6LvpxPoen5f.png)



### 推导和归约

#### 直接推导

#### 直接推导序列

#### 最左推导

#### 最右推导

#### 句型【由S“星推导”出来的串】

#### 句子【都是终极符的句型】

#### 短语【由句型定义，并且短语一定是在所定义的句型中连续出现的】

![image-20201114111557664](https://i.loli.net/2020/11/14/gadw9SVRMZInrBj.png)

![image-20201114111622117](https://i.loli.net/2020/11/14/gStL6N2abJ3AfrU.png)

#### 句柄【由短语定义】

- 一个**句型**的**最左**直接短语

#### 语法树

##### 语法树的作用是什么？

- 反映出**推导过程**，每一步节点的生长过程都可以对应到一步推导。
- 反映出串的**语法结构**。

##### 语法树的定义

- 设G是给定的文法， 称满足下列条件的树为G的一棵语法树：
  1. 每个节点都标有C的一个文法符号， 且根节点标有初始符S, 非叶节点标有非终极符。
  2. 如果一个非叶节点A有n个儿子节点`B1 B2 B3...Bn`（按从左到右顺序）， 则$A\rightarrow B_1B_2B_3...B_n $一定是C的一个产生式。

##### eg

![image-20201117153024706](https://i.loli.net/2020/11/17/wUq8HaYZuC6EKh3.png)

![image-20201117153145083](https://i.loli.net/2020/11/17/Ct5VWmve9zSFb7T.png)

![image-20201117153201982](https://i.loli.net/2020/11/17/LasIk9pbG6TPRov.png)

- 上面的例子可以体现出文法的二义性问题



#### 文法二义性【一个句子，多个树】

- 对一个文法G, 如果至少**存在一个句子**， 有**两棵（或两棵以上）不同的语法树**， 则称该句子是二义性的。包含有二义性句子的文法称为二义性文法， 否则， 该文法是无二义性的。也就是说， 若一个文法中存在某个句子， 它有两个不同的最左（或最右）推导， 则这个文法是二义性的。

#### 文法的二义性可判定吗？

- 人们已经证明，文法的二义性是不可判定的

### 文法等价变换

- **定理**：对任一文法$G_1$ 都可以构造文法$G_2$  使得L($G_1 $)=L($G_2$) , 且$G_2$ 有这样的特点： 文法的**开始符唯一**，并且**不出现**于任何产生式的**右部**。
- **定理**：对于任一文法$G_1(\varepsilon \in L(G_1))$ , 可构造文法$G_2$ 使得$L(G_1)=L(G_2）$， 并且$G_2$ 中无空产生式。

#### 如何消除文法中的空产生式【产生空的规则】？

- 构造产生空的规则的左部的集合$\beta$【$\beta \in V_N$】
- 根据**补充规则**来消除某个空表达式
- <img src="https://i.loli.net/2020/11/14/Gznj4WiNYP1OMTs.png" alt="image-20201114154630709" style="zoom:50%;" />
- 重复这个过程

##### eg

![image-20201114154749287](https://i.loli.net/2020/11/14/Q5B9jfacmOqPYlr.png)

- **定理**：对任一文法G1, 都可以构造文法G2 ，使得L(G1)= L(G2 ) , 并且G2 的每个非终极符必出现在某个句型a【由$S *\Rightarrow a $的符号串】中。
- **定理**：对任一文法G1 , 可以构造文法G2 , 使得L(G1 )=L(G2 ), 并且在G2 中没有特型产生式。

#### 什么是特型产生式？

- 把文法中形如$A\rightarrow B$(**B 为非终极符**）的产生式称为特型产生式。【**注意**这里表达式的描述】
- **特型产生式**在语法分析中会降低分析速度， 因此应该**消除**。

#### eg 去除特型表达式和无用表达式

![image-20201114155802497](https://i.loli.net/2020/11/14/8ihQmvxfVJ6CpkK.png)

#### 不满足自顶向下的语法分析条件

- 若非终极符A的不同产生式的**右部**具有**相同**的**前缀**，这种情形不满足自顶向下的语法分析条件

#### 如何消除产生式的公共前缀？

- 提取左因子
- <img src="https://i.loli.net/2020/11/14/3fKxoLNX5dbZHAw.png" alt="image-20201114160225834" style="zoom:50%;" />

#### 什么是直接左递归？

- 如果文法中的某个非终极符A有产生式A--->A…， 则称A是直接左递归的。

#### 什么是左递归？

- 如果文法中的某个非终极符A有推导式A *⇒ A…， 则称A是左递归的。

#### 为什么要消除左递归和直接左递归？

- 直接左递归和左递归情形， 一定**使得自顶向下语法分析方法的分析条件不成立**， 应予以消除

#### 如何消除直接左递归？

- **替换，将其变成右递归**

- <img src="https://i.loli.net/2020/11/14/dz9Omekl2JA7EW3.png" alt="image-20201114160819307" style="zoom:50%;" />

#### 消除直接左递归意味着已经消除了整个文法的左递归性吗？

- 不是

#### 如何消除左递归？

1. 提取公共前缀
2. 消除左递归



- 不断通过推导式来得到直接左递归，消除直接左递归
- ![image-20201114164301101](https://i.loli.net/2020/11/14/v8b1aEFqmOknt9D.png)







### 文法的例题

#### 构造文法 满足描述

写一个文法，使其语言是偶正整数的集合
$$
\\允许0开头
S\rightarrow NS|D
\\D\rightarrow 0|2|4|6|8
\\N\rightarrow D|1|3|5|7|9\\不允许0开头\\
S\rightarrow NT|D\\
T\rightarrow KT|G\\
D\rightarrow 2|4|6|8\\
N\rightarrow D|1|3|5|7|9\\
G\rightarrow 0|D\\
K\rightarrow 0|N
$$

#### 由语言构造文法？？不懂

![image-20201117212021394](https://i.loli.net/2020/11/17/8gK5xI9oDNGQPjw.png)

#### 由语言构造文法例题2

$$
L={1^n0^m1^m0^n|n,m>=0}
$$

- ```
  S=A|B
  A=1A0|B
  B=0B1|空
  ```






#### 判断文法是否具有二义性？

![image-20201117212120781](https://i.loli.net/2020/11/17/xICcil6zbNgR2ep.png)

- 画树即可





## 有限自动机FA

### 确定有限自动机DFA

#### 什么是DFA

- DFA  M是一个五元组
- $M=(S,\Sigma ,f,s_0,Z)$，其中
- S：一个**有限**状态【也就是结点】的集合
- $\Sigma$：一个**有穷**字母【也就是边】表
- f： 状态转换函数，从$S*\Sigma$到$S$的一个**单值全映射**，但是当省略**陷阱状态**后，f不再是全映射
- $s_0$：**唯一初始**状态，$s_0 \in S$，可以使用**箭头**或者**+**来表示
- Z: **终止状态集合**，$Z \subseteq S$，可以使用**双圆圈**或者**-**来表示

#### 什么是语言【L(M)】?

- 若字母表上的字符串a，存在一条从$s_0$到Z的通路，则称a是可被M锁能接收的
- 那么所有的这些字符串a构成的集合是它所定义的**语言**，称为L(M)

#### 确定有限自动机可以使用什么来表示？

- 五元组
- 状态转换图

- 状态转移矩阵【关系矩阵】

#### 为什么要定义陷阱状态？

- 为了定义的完备性

#### DFA的确定性体现在？

- 初始状态唯一
- f是一个单值函数

#### eg

<img src="https://i.loli.net/2020/11/11/RhUfZFEJkYiCHtS.png" alt="image-20201111230343100" style="zoom:67%;" />

<img src="https://i.loli.net/2020/11/11/5ImvoT1y2PsbrRZ.png" alt="image-20201111230357575" style="zoom:90%;" />

<img src="https://i.loli.net/2020/11/11/1N6EJdYDAtswVOl.png" alt="image-20201111230417664" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/11/11/tRucGhpeaHJMIKW.png" alt="image-20201111230433174" style="zoom:87%;" />



### NFA

#### 什么是NFA【非确定有限自动机】？

- 是一个五元组$(S,\Sigma,f,S_0,Z)$,**注意**，这里改成了$S_0$，也就是说是一个状态的集合
- S：一个**有限**状态【也就是结点】的集合
- $\Sigma$：一个**有穷**字母【也就是边】表
- f:是一个从$S*(\Sigma \cup \{\varepsilon\})$到**S的子集**的映射，**注意**有空集，而且结点+边到**结点集合**的映射
- $S_0$: $S_0\subseteq S$，**注意**，是**非空集合**
- Z：终止状态集合

#### DFA和NFA的区别是什么？

1. 对于DFA，确定性表现在初始状态唯一
2. 映射是单值函数【也就是只有1条边】
3. NFA允许有空边



#### eg

![image-20201111231233093](https://i.loli.net/2020/11/11/GmuZyp5DX1Je9Hb.png)

![image-20201111231311618](https://i.loli.net/2020/11/11/Ncz5yaqtZ8HKDIu.png)

### DFA和NFA等价

#### 有限自动机等价的定义

- 对于有限自动机A和B，若存在L(A)=L(B)，则称有限自动机A和B**等价**【**注意**这是自动机等价的定义而并不是状态的等价】

#### 任何NFA都存在一个对应的DFA吗？

- 一定【定理2.5】
- 对任何一个NFAM, 都存在一个DFAM', 使得L(M')=L(M)。

#### 转换算法

- 写出**初始状态闭包S**，**初始状态S通过a到达的闭包A**，**初始状态S通过b到达的闭包B**...
- 写出**B通过a到达的闭包C**。。。。
- 直到没有新的闭包出现，则结束
- 编号



##### eg

![image-20201111234159658](C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201111234159658.png)

![image-20201111234225465](https://i.loli.net/2020/11/11/Jdt4q8E92h5wCWT.png)



### DFA的化简

#### 什么是等价状态？

- 设DFA M 的两个状态 S 1 和 S 2 , 如果对**任意**输入的符号串 x ，**从 S1和 S2 出发**，总是**同时**到达接受状态或拒绝状态中**【最终状态】**，则称 S 1 和 S 2 是等价的。不然则称其是**可区分的**

#### 什么是无关状态？

- 从有限自动机的初始状态开始， **任何输入序列都不能到达的那些状态**称为无关状态。【可以理解为孤立状态】

#### 什么是最简自动机？

- 如果DFA M **没有无关状态**，也**没有等价状态**，则称 M 为最小自动机

#### eg

- 对下列DFA进行最小化

![image-20201113215620161](https://i.loli.net/2020/11/13/sfOF3oaVxq6e2nm.png)



- ans

![image-20201113215935100](https://i.loli.net/2020/11/13/HcWPLV395Qx6a2w.png)



## 正则表达式

### 正则表达式和正则集

#### 正则表达式和正则集的递归定义

![image-20201113220238237](https://i.loli.net/2020/11/13/RIrfhPzqVmL7Q3c.png)

- 正则表达式r所表示的正则集一般记作L(r)

#### 正则表示的等价

- 若两个正则表达式r和s所表示的正则集相等，即L(r)=L(s), 则称r和s等价

### 正则表达式与有限自动机的相互转换

#### 正则表达式和NFA等价存在性

- 总存在一个正则表达式R和非确定有限自动机M等价，反之亦然
- 证明**略，见p30**

# 词法分析

### 词法分析中可以发现的错误有哪些？

- 单词拼写
- 非法字符



### 词法分析程序的功能是什么？

- 读入**源程序字符串**， **识别出各个单词**并将其**转换成相应的内部表示**， 即TOKEN序列

### 什么是单词？

- 单词是指语言中那些具有独立含义的**最小语义**单位。

### 单词[token]的组成是什么？

- 单词类别
- 语义信息【是指向常量表或符号表中相应位置的指针】

### 词法分析程序的接口【2类】

#### 作为独立一遍的词法分析器

#### 作为子程序的词法分析器

![image-20201113221643843](https://i.loli.net/2020/11/13/8ug9RK2T14f7IqQ.png)

## 词法分析程序的设计

### 单词【TOKEN】分类

#### 保留字【系统定义，比如for]

#### 标识符【用户定义,比如变量名】

#### 常量【比如数字】

#### 特殊符号【运算符和界限符】

### 单词的内部表示

```
[类型|内容]
```

![image-20201113222018034](https://i.loli.net/2020/11/13/HIPfomGORXACKl1.png)



### 单词的形式描述

#### 描述单词的工具主要有3种

- 正则表达式
- 自动机
- 正则文法

## 词法分析程序的实现【略讲】

### 实现词法分析程序应注意的问题

#### 1保留字

#### 2复合单词的识别

#### 3数的转换

#### 4向前看若干个字符的处理

#### 5控制字符的处理

#### 6注释的处理

#### 7标识符表和常量表



# 语法分析-自顶向下

## 语法分析介绍



### 语法分析程序的功能

#### 语法分析的功能是什么？

- 把词法分析输出的单词TOKEN作为输入，按照文法规则，从其中识别出各类语法成分，从而进行语法检查，为语义分析和代码生成做准备。

#### 语法分析器和识别器的区别是什么？

- **识别器**主要功能是识别输入的字符串是否合法
- **语法分析器**主要是识别输入字符串的合法性和**语法结构**
- **单词处理**实际上用的是**识别器**

### 语法错误类别和错误处理

#### 单词的错误及其处理由什么来完成？

- 由词法分析器来完成

#### 语法错误及其处理由什么完成？

- 由语法分析器来完成

#### 常见的语法错误有哪些？

- 单词错误
- 标识符和常量单词错误
- 括号类错误
- 分隔符错误

#### 常见的语法错误处理有哪些？

- 紧急方式恢复【发现错误，分析器抛弃输入记号，不会导致死循环】
- 短语级恢复【发现错误，对剩余输入记号进行局部修正，可能会产生死循环】
- 出错产生式【增加产生错误结构的产生式，换句话来说就是预判了其错误，并且纳入了产生式中】
- 全局纠正【玄学】

### 自顶向下语法分析的基本思想“它来了！”

#### 什么是LL1文法【定义】【自顶向下语法分析的充分必要条件是什么？】

- 对于文法G中任一非终极符A，其任意两个产生式都要满足以下条件
  $$
  Predict(A\rightarrow a)\cap Predict(A\rightarrow \beta)=\emptyset
  $$



#### 自顶向上的语法分析的基本思想

- 自顶向下分析是从文法的**开始符号**出发， 试图为输入串建立一个**最左推导**， 或者**为输入串构造一棵语法树**。

#### 为什么要采用3个集合？

- 仅仅是为了自顶向下语法分析的中避免回溯

### 3个重要集合【重要！】

![image-20201117223456397](https://i.loli.net/2020/11/17/9jZDLtxMydH2kXa.png)

#### First($\beta$) 

- 由$\beta$串能推出的**首个终极符的集合**【把计算方法的等号可以替换成$\Rightarrow$】
- 当有产生式$X\rightarrow Y_1Y_2...Y_n$的时候，若$Y_1Y_2...Y_{i-1}\ *\Rightarrow \varepsilon$，则$First(F_i)\sube First(X)$。

-  ![image-20201117224749877](https://i.loli.net/2020/11/17/1h6ZsrBXjKVQ4ea.png)

#### Follow(A)

- 在某个**句型**中，出现在A后面的**终极符的集合**【注意，A是在右部分的】
- 找到在某个规则的右部的字符串中其右边没有可以扩展的符号即可
- ![image-20201117224918219](https://i.loli.net/2020/11/17/3Vjy4v6QnIOdXhq.png)

#### Predict($A\rightarrow \beta$)【代表当前可以推导的首个终极符】

- 选择$a\in First(\beta)$的规则推导
- 当$\beta$能推导出**空**的时候，可以选择$a\in Follow(A)$的规则来推导

##### 为什么引入Predict集合？

- 可以决定使用哪一个产生式进行推导

- ![image-20201117225035795](https://i.loli.net/2020/11/17/fFaSzw8LbnRKEei.png)



### 对于不是LL1文法的文法，如何转换为LL1文法？

- 消除公共前缀
- 消除左递归

#### 消除公共前缀和左递归一定就是LL1文法吗？

- 不一定

#### 举例不是LLk的文法

- if-then-else结构语句

#### eg

![image-20201119210557224](https://i.loli.net/2020/11/19/umg5ctkdil68N3A.png)



## LL1分析方法

### LL1命名

- L：从左至右推导
- L：产生一个句子的最左推导
- 1：每进行一步推导要看一个输入符号

### LL1分析法原理

#### LL1分析器由什么组成？

##### 输入流【待分析的符号串，以#为结尾】

##### LL1分析表【行：一个非终极符，列：一个终极符，元素：产生式或者error】

##### 符号栈【文法的一个左句型】

##### 驱动程序【没什么特别的意思，可以理解为算法】

### LL1分析表构造

#### eg

- 产生式与**3个重要集合**相同

![image-20201119212153756](https://i.loli.net/2020/11/19/uaYOhnGXs9PI31M.png)

### LL1驱动程序的构造

#### LL1的4个动作

##### 替换【推导并替换】

##### 匹配【匹配并退栈】

##### 成功

##### 报错

#### eg

![image-20201119212852483](https://i.loli.net/2020/11/19/aIWUJGrE4lgOH6p.png)



## 递归下降方法

![image-20201126104222927](https://i.loli.net/2020/11/26/CFvUXyelsTmKiB2.png)

![image-20201126104233440](https://i.loli.net/2020/11/26/LimqSzawMbEo1sU.png)

# 语义分析

## 语义分析概述

### 语义的分类

#### 静态语义【编译阶段可以检查处理】

#### 动态语义【在运行时才能检查出来的语义】

### 语义检查的分类

#### 一般性语义检查

- 如S[i]的语义检查：S是不是数组类型

#### 类型语义检查

### 标识符在程序中的出现分类

#### 声明性出现

#### 使用性出现

### 标识符的属性

#### 名字【一般不允许重名】

#### 类型

#### 存取方式

##### 直接存取

##### 间接存取【比如指针】

#### 存储方式

##### 静态【static extern，运行前数据分配好存储区 静态区】

##### 动态【auto register，运行时才分配 栈区 】

### 标识符的内部表示

#### 常量标识符

![image-20201120162302575](https://i.loli.net/2020/11/20/PVgMJZxSc792Nlb.png)

#### 变量标识符

![image-20201120162531217](https://i.loli.net/2020/11/20/BwOLn3jI4uv9YMk.png)

![image-20201120162347058](https://i.loli.net/2020/11/20/9Z4dcFz5XI1Jeox.png)

![image-20201120162517842](https://i.loli.net/2020/11/20/zsdlC2t1BbfrUF8.png)

#### 类型标识符

<img src="https://i.loli.net/2020/11/20/6HMWDu7bNx4KvQ5.png" alt="image-20201120162731815" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/11/20/ktpahTJCNBUzxyl.png" alt="image-20201120162758669"  />

<img src="https://i.loli.net/2020/11/20/V5BCoNDisyqOmRF.png" alt="image-20201120164731995" style="zoom: 67%;" />

- 其中本书规定RealSize 为2，其它的为1

##### 数组类型

<img src="https://i.loli.net/2020/11/20/zhIMJv8LDmuAXeT.png" alt="image-20201120165414277" style="zoom:50%;" />

![image-20201120165433381](https://i.loli.net/2020/11/20/1ThbJCUaG9pLrQA.png)

<img src="C:\Users\Xxgzbd\AppData\Roaming\Typora\typora-user-images\image-20201120165443914.png" alt="image-20201120165443914" style="zoom:50%;" />

##### 结构体类型

<img src="https://i.loli.net/2020/11/20/l31sJXyhQLKmDEw.png" alt="image-20201120165545383" style="zoom: 50%;" />

- 注意在内部表示中加入一个link域表示下一个内部表示



##### 枚举类型

<img src="https://i.loli.net/2020/11/20/pANnx2GlFYEkW87.png" alt="image-20201120165638028" style="zoom:50%;" />

<img src="https://i.loli.net/2020/11/20/MLjNhmAfYyicpgu.png" alt="image-20201120165720215" style="zoom:50%;" />

<img src="https://i.loli.net/2020/11/20/6Jfn8ThxeFOWlw1.png" alt="image-20201120165701831" style="zoom:67%;" />

##### 指针类型

<img src="https://i.loli.net/2020/11/20/9gOfS7XWz3wB4Lp.png" alt="image-20201120165841933" style="zoom:67%;" />





#### 过程函数标识符

```
Name Kind Type Class Level [Off 只对formal有效] Param,参数表指针  
```

![image-20201120163425776](https://i.loli.net/2020/11/20/pQJBD5oG8UqLxNY.png)

##### 哪2个属性在语义分析阶段没有使用？

- Code和Size，这2个属性是在目标代码生成时回填时使用

##### eg

![image-20201120163815592](https://i.loli.net/2020/11/20/rB4Xc5pZHQLGzbM.png)

![image-20201120163831351](https://i.loli.net/2020/11/20/VYg62mdwhDlubxv.png)

#### 域名标识符

![image-20201120164142647](https://i.loli.net/2020/11/20/CtFLVm6JUNRrbXZ.png)

![image-20201120164204161](https://i.loli.net/2020/11/20/EcLbfN4sMnJAmuF.png)

![image-20201120164225978](https://i.loli.net/2020/11/20/tKUBVOXsqfwNG8n.png)

## 符号表的管理【可以把Scope栈理解为对于符号表的管理】

### Scope栈的作用是什么？

- 在不同时刻，不是所有符号表都有效，Scope栈的作用是为了标识哪些符号表有效。
- 它存放的是当前有效的符号表的起始地址
- 每当进入一个局部化区，把它的首地址压入栈；退出反之



### 符号表的建立与访问

### 符号表的组织

### 符号表的局部化处理

#### 什么是标识符的作用域？

- 标识符的有效程序段称为标识符的作用域

#### 什么是标识符的嵌套作用原则？

- 若外层有和内层同名的标识符，则外层对应的标识符将内层作用域**剔除**

#### 局部化区域删除的方法有哪些？

- 真删除法
- 驻留法

#### 在组织上看，符号表的分类有哪些？

##### 局部式符号表

###### 如何判断哪一个符号表是有效的？

- 使用Scope栈【用于存放局部符号表的起始地址】

##### 全局式符号表

- 真删除法和驻留法都是全局符号表的删除方式

#### 分程序嵌套的层数和过程函数嵌套的层数的区别？

- 过程函数嵌套的层数是为了**分配内存地址**提出的，不同层数对应不同内存块的**起始地址**
- 分程序嵌套中，外层分程序和内层分程序的层数相同

#### 如何实现分程序结构的标识符作用域问题？

- 在标识符中添加一个属性：标识符所属分程序的编号



#### 全局符号表属性的表示

| name | kind      | type            | level | off                                                  | access/class    | value/param  | code | size | foward     |
| ---- | --------- | --------------- | ----- | ---------------------------------------------------- | --------------- | ------------ | ---- | ---- | ---------- |
| 常量 | constkind |                 | 无    | 无                                                   | 无              |              | 无   | 无   | 无         |
| 变量 | varkind   |                 |       |                                                      | dir/indir(指针) |              | 无   | 无   | 无         |
| 函数 | routkind  | 返回值的type    |       | 只对formal有效,占有2个单元 [入口地址，display表信息] | actual/formal   | 参数表首地址 | NULL | size | false/true |
| 类型 | typekind  | 可以是自定义ptr | 无    | 无                                                   | 无              | 无           | 无   | 无   | 无         |



```
name     	kind 			type 		level 		off		 access/class 		value/param 		code 		size 		foward
	    	constkind		realptr      无          只有       dir/indir
	    	varkind 		intptr				    varkind
	    	routkind        (在函数中表	 			改变off
	    				  示返回值的type)  
	    	typekind        （在类型中可以  无			无		无				无				无			无			无
	    					是自定义ptr
	    					也可以是realptr等）
```



#### 符号表的例题

![image-20201127111810646](https://i.loli.net/2020/11/27/GaseI2mT9zdcnjB.png)









# 中间代码的生成

## 前言

### 直接生成目标代码的好处是什么？

- 可避免重复性工作

### 使用中间代码的好处是什么？

- 便于编译器的移植，修改和优化
- 可以在中间代码一级进行优化处理，使得目标代码更加简单
- 使得编译程序在逻辑结构上更简洁

### 中间代码的分类

#### 三元式

- `(操作符，运算分量，运算分量)`

#### 后缀式中间代码

- 排好了计算顺序

#### 抽象语法树

- 显示地表示源程序的结构

#### 无环有向图

#### 四元式

- `(算符op，ARG1，ARG2，运算结果RESULT） `

### 什么是语法制导方法？

- 在进行语法分析的同时要完成相应的语义动作

![image-20201124152118174](https://i.loli.net/2020/11/24/27Q3nxIliO8AZbg.png)

#### eg

![image-20201124142942690](https://i.loli.net/2020/11/24/owyBtJxOfWsYTm1.png)

![image-20201124142951464](https://i.loli.net/2020/11/24/zcFGdPnMABau87H.png)











## 中间代码生成的几个问题

### 操作分量或运算结果的地址表示为

1. 标号类【过程函数的入口标号】
2. 数值类【数据值】
3. 地址类【层数，偏移，访问方式】

### 访问方式有什么分类？

##### 直接访问

##### 间接访问

### Sem语义栈

- 用于存放运算分量和语义信息

### 语义子程序



- `push(x)` 将`x`的类型和语义信息压入`Sem`栈中
- `pop(n)` 将`Sem`栈顶的n个元素弹栈

#### 申请临时单元

- `new_dir(t)` 在临时变量区申请一个t，且t是直接寻址
- `new_indir(t)` 在临时变量区申请一个t，且t是间接寻址

#### 存放中间代码子程序

- `Generate(w,left,right,result)` 

#### 产生一条四元式中间代码

- `GenCode(w)`
- 从语义栈Sem中删除左、右运算分址Sem[ top -1]和Sem[top], 并把运算结果的类型和运算结果的FORM压入Sem栈。

- 其中

  - 对于临时变量的层数取-1

  

## 表达式的中间代码生成

- 定义表达式的`LL(1)`文法

  ![算术表达式的LL1文法定义](https://i.loli.net/2020/10/14/63UfCaBut5lIqLE.png)

![屏幕截图 2020-10-14 162734](https://i.loli.net/2020/10/14/qUVofvhlNejZ78Q.png)

- 当遇到常量C和简单变量id时， 把它们的语义信息压入语义栈（产生式9) 和10))。
- 当处理完一个运算符（＋、－、＊ 、／）的右分量时， 该运算符的左、右运算分量已经分别存放在语义栈`Sem`的次栈顶和栈顶的位置， 因此可以生成相应的运算符的四元式，并把运算结果的语义信息压入语义栈（产生式3) 、4)、7)和8))。

![image-20201124150005981](https://i.loli.net/2020/11/24/S35nDLgWmJIdAKO.png)



## 下标变量的中间代码生成

- ![image-20201124153535122](https://i.loli.net/2020/11/24/HGwrtCUlQPORysv.png)

![image-20201124153724429](https://i.loli.net/2020/11/24/E3IkiLGrJAbP7ea.png)

![image-20201124154300507](https://i.loli.net/2020/11/24/rgCJEyS3ZTkXUfp.png)

## 赋值语句的中间代码

```
(ASSIG ,  Right, - ,  Left )
```

![image-20201124154430105](https://i.loli.net/2020/11/24/PXYOwHbvgyir39h.png)

## 过程调用和函数调用的中间代码

- **true静态确定转向地址；false:动态确定转向地址**，
- 可以理解为ture则是**实在**函数，false则是**形参**函数

### 函数调用的中间代码

#### 值参

```
(ValACT,t,Offset,Size)
```

#### 变参

```
(VarACT,t,Offset,Size)
```

### 调用代码

```
(CALL,函数/过程入口,true[实在函数]/false[形参函数],[Result])
```



- 过程调用没有返回，函数调用有返回

### 过程/函数调用要检查的语义错误

- 名字是不是过程函数标识符
- 形参和实参类型是否匹配
- 实参个数和形参个数是否相等

### eg

![image-20201124155111975](https://i.loli.net/2020/11/24/3Iu8YAWU64JXbGn.png)

### eg

- **例：x + f (H(10), g(Y))**
- x是整型变量
- H为**返回值是整型的形参函数名**
- H的 形参为整型值参
- f,g为返回值是整型的实在函数
- f的参数均为整型值参
- g的参数为变参。

![image-20201124155545593](https://i.loli.net/2020/11/24/a8LzFJvID2fHPtx.png)



## 控制语句的中间代码生成

### goto语句和标号定位的中间代码

#### 转向语句goto L

```
(JMP,-,-,L)
```

#### 标号定位

```
(LABEL,-,-,L)
```



#### 实现过程

##### 2个表

- 标号表T1，未找到定位标号表T2
- ![image-20201203153847488](https://i.loli.net/2020/12/03/5ce3dBECmMUzYtT.png)

![image-20201203153947540](https://i.loli.net/2020/12/03/4kBlvLQYUM1CJtu.png)

##### eg

![image-20201203154125631](https://i.loli.net/2020/12/03/qurRn3UWBKjMAeI.png)



### 条件语句的中间代码

```c++
(THEN,Sem[top],-,-) 	//产生条件转移
(ELSE,-,-,-)			//转移，定位
(ENDIF,-,-,-)			//定位
```

### while语句的中间代码

```c++
(while,-,-,-)\\定位
\\E的中间代码
(DO,E.FROM.-,-)\\转移
\\S的中间代码
(ENDWHILE,-,-,-)\\定位，转移
```

## 过程/函数声明的中间代码

### 除了过程函数有声明之外还有声明是产生中间代码的？

- 其他声明都不可能产生中间代码

### 中间代码

```pascal
(ENTRY,Labelq,Sizeq,Levelq)\\Labelq是代码入口标号，Sizeq是AR大小，只有在代码处理完临时变量才能完全确定，Levelq是层数
(ENDPROC,-,-,-)\\
```

- 在语义分析阶段填写size
- 在中间代码生成和中间代码优化阶段修改size
- 在目标代码生成阶段使用size

### eg

![image-20201124202355423](https://i.loli.net/2020/11/24/lz79pwGauTYSjyh.png)

### eg

```pascal
A[1..10]of integer;
a:=1;
while a<=10 do
	begin  
		if a<>b then   				 	
			A[a]:=A[b]+2
         else  a:=a+1;  
         b:=b+1;
     end
```

```c++
(=,1,-a)
(WHILE,-,-,-)
(<=,a,10,t0)
(DO,t0,-,-)
(<>,a,b,t1)
(THEN,t1,-,-)

(-,a,1,t2)
(*,t2,1,t3)
([],A,t3,t4)
(-,b,1,t5)
(*,t5,1,t6)
([],A,t6,t7)
(+,t7,2,t8)
(=,t8,-,t4)

(ELSE,-,-,-)
(+,a,1,t9)
(=,t9,-,a)

(ENDIF,-,-,-)
(+,b,1,t10)
(=,t10,-,b)

(ENDWHILE,-,-,-)
```

# 中间代码的优化

## 优化方法概述

![image-20201124205105716](https://i.loli.net/2020/11/24/Lh2oTEaBqp9DuyR.png)

### 局部优化

#### 循环上的优化

##### 循环不变式外体

##### 削减运算强度

#### 基本块的优化

##### 常表达式节省

##### 公共子表达式节省

### 全局优化

####   全局数据流分析，从而使优化的效果更好

## 基本块划分

- 遇到转移性中间代码A，A为当前基本块的出口，A+1是新基本块入口
- 遇到标号型B，B为新基本块入口

### 中间代码的划分

#### 标号性中间代码

```
(LABEL,-,-,L)
(ENTRY,LABEL,Size,Level)
(WHILE,-,-,-)
(ENDIF,-,-,-)
```

#### 转移性中间代码

```
(JMP,-,-,L)
(ENDPROC,-,-,-)
(ENDFUNC,-,-,-)
(THEN,E,-,-)
(ELSE,-,-,-)
(DO,E,-,-)
(ENDWHILE,-,-,-)
```





## 常量表达式局部优化【属于基本块的优化，优化的是运算的表达式】

### 算法过程

- **常量定值表**ConDef：(Var,Val)。

- 在基本块入口处置ConDef为空
- 读当前四元式tuple
- 对tuple中的分盘进行值代换得newtuple
  - 若newtuple是**(w,A,B,t)**，若A和B是常数，则在ConDef中填入**(t,AwB的运算结果)**，删除该中间代码
  - 若newtuple是**(assign,A,-,B)**，若A是常数，则把**(A,B)**覆盖填入ConDef，否则从ConDef中删除

![image-20201126155525898](https://i.loli.net/2020/11/26/UI2dJ4BLpST3t6X.png)

## 公共表达式局部优化【基本块的优化】

### 基于相似性的公共表达式节省

#### 必经代码是什么？

- 称a代码是b代码的必经代码，若执行b的时候a一定执行过

#### 活跃代码是什么？

- 称a(ω,A,B,t1)在b处是活跃的：若a是b的必经代码，且a到b期间，A和B的值不改变

#### 什么是ECC代码【可节省代码】

- 计算结果相同的活跃代码

#### 相似代码

- 若a和b的运算符，运算分量相同，则称a和b是相似代码

####  ECC定理

- 当前代码b`(w,A,B,t)`，若存在**相似**的**必经活跃**代码，则b一定是活跃代码
- 这是判定ECC的充分条件，不是充要条件

##### eg

```
(+,A,B,T1)
(+,A,B,T2) 
(*,T1,T2,T3)
//优化为
(+,A,B,T1)
(*,T1,T1,T3)
```

#### 判断a是ECC的2个要点

1. 判断是否ECC
2. 等价替换

#### 基于相似性公共表达式节省的2个表

- 活跃代码表
- 等价变量表

#### 基于相似性公共表达式节省的2个操作【可以看出活跃代码表中存有的都是运算代码

- 若当前代码是**运算**代码(w,A,B,t)，【1】查找活跃代码表中的表项，看A和B是否相似。【2】若有，则可节省，并填写等价变量表
- 若为**赋值**运算(=,A,-,B)，【1】查找活跃代码中的表项，看是否有分量有B的【2】若有，则从活跃代码表中去除，并且去除和t等价变量表中的内容

### 基于值编码的公共表达式节省

#### 3个表

- 值编码表
- 等价表
- 四元式编码表

#### 2个操作

- 若是运算代码(w,A,B,t) 【1】看相同运算的A,B是否编码 【2】则把t和原来的运算结果填入等价表中【3】删除改运算代码
- 若是赋值运算(=,A,-,B) 【1】看A是否有编码，有则不变，没有则得到新编码【2】B的编码和A的编码一致，但是这里并不需要把A和B填入等价表中
- 换句话来说：赋值运算只会改变值编码表，不会剔除等价表中的东西

#### 





#### 与基于相似性的节省区别是什么？

- 扩大ECC：相似代码的定义扩充为不局限于分量的名字相同

#### eg

```
a=b*c+b*c;
d=b;
e=d*c+b*c;
```

![image-20201126162318812](https://i.loli.net/2020/11/26/heJXB8uRITAga6W.png)

## 循环不变式外提

### 算法过程

#### 第一遍扫描

- 运算四元式`(w,A,B,t)` 则把t填表中
- 赋值`(=,a,-,b)`，则把b填到表中

#### 第二遍扫描

- 若遇到一个运算型`(w,A,B,t)`若A和B都不在定值表中，则将其提到循环体外，并且删除t

### 注意的问题

- 多层循环，外提多次
- 除法不外提
- 赋值绝不外提
- 函数调用和地址引用不外提



# 运行时存储空间的组织与管理



## 目标代码运行时的存储结构

### 目标代码运行时的内存的划分

- 其中， 

#### 库代码空间

#### 目标代码空间

#### 静态区空间

#### 栈区空间

#### 堆区空间

- 动态申请和释放的内存



#### 这些空间是在什么时候分配的？

- 代码区和静态区空间是在编译时分配的， 栈区空间和堆区空间是在运行时分配的。



#### 如何计算变量的实际地址？

- 许多目标机的目标代码中常常用一个专门的**寄存器**来记录**栈顶**的值， 这个寄存器则被命名为top。若变址x相对栈顶top 的偏移扯记为Offsetx, 则变社x 的内存地址是**top-Offsetx**。
- 有的目标机用两个寄存器分别表示栈底和栈顶的值， 分别记为**sp** 和**top**。此时， 变址的偏移址都是相对栈底sp而言的， 假设变址y 的偏移是Offsety, 则变址的内存地址是**sp +Offsety**。

![image-20201103150835034](https://i.loli.net/2020/11/03/nINqGFOa6ZKtW5P.png)



#### EG  C语言代码对应运行时内存示意图

- 注意：是运行时

![image-20201103150911331](https://i.loli.net/2020/11/03/HMUlLPJKsA36WcX.png)

### 目标程序运行时的存储分配策略

#### 有哪些存储分配策略？

##### 动态存储分配策略

- 动态存储分配策略又可分为栈式动态存储分配策略和堆式动态存储分配策略。

###### 栈式动态存储分配策略

###### 堆式动态存储分配策略

##### 静态存储分配策略



#### 什么是静态分配策略？

- 在编译时间为所有数据对象分配**固定**的存储单元
- 在运行时间保待不变



#### 存储空间分配的本质是什么？

- 将程序中每个变量名字与一个存储位置关联起来，·该存储位置用以容纳该变量的值。

#### 影响存储分配策略的语言特征

- 过程能否**递归**。
- 当控制从过程的活动返回时，局部变量的值是否要保留。
-  过程能否访问非局部变量。
- 过程调用的参数传递方式。
-  过程能否作为参数被传递。
- 过程能否作为结果值传递。
-  存储块能否在程序控制下动态地分配。
- 存储块是否必须显式地释放。



#### 静态存储分配策略

- 每个过程活动记录大小必须是固定

##### 静态存储分配策略的约束条件

- 不允许递归过程，因为一个过程的所有活动使用同一个活动记录
- 不允许可变体积的数据
- 不允许动态建立数据结构【指针，动态数组】

#### 栈式动态存储分配策略

##### 为什么无法确定每一个活动记录的起始地址和每一个活动记录中数据的绝对地址？

- 每个过程活动记录都是根据目标代码的执行情况动态分配的。但是可以确定在活动记录中的相对位置【偏移量】

##### 栈式分配策略可以解决哪些问题？

- 递归调用问题
- 空间共享的问题

#### 堆式动态存储分配策略

##### 为什么要堆式动态存储分配策略？

- 程序设计语言允许用户自由地申请和释放数据空间， 即空间的使用未必服从“ 先申请后释放， 后申请先释放” 的原则

##### 缺点

- 实现代价大

## 过程活动记录和运行时栈【重点】

### 过程活动记录

#### 什么是过程活动记录AR Activation Record

- 给被调用过程分配一段**连续**的存储空间，以便存放 该过程的局部变扯值、保存中间结果的临时变址、过程调用的控制信息等内容。

#### 过程活动记录的域有哪些？

- 动态链指针，用来指向**调用者**的活动记录的起始地址， 即老sp。
- 返回地址，指向 **调用者过程**调用指令对应的目标代码的**下一条目标指令**
- 返回值，调用者中用于**存放返回值**的临时变量的地址
- 寄存器状态，即**中断现场**
- 过程层数，用于程序非正常出口情形处理，一般不用记录
- 活动记录空间大小，用于过程调用返回时返回到**指定地址**。
- 变量访问环境，构造非局部数据访问环境，如Display 表，静态链指针
- 形参变量区，用于存放**调用过程**向**被调用过程**提供的实在参数。
- 局部变量区，保存过程局部声明的数据。
- 临时变量区

#### top寄存器的作用是什么？

- 用于指向当前活动记录的最新**可分配**地址的专用寄存器
- top-sp即为**活动记录空间的大小**，因此，只要top寄存器与”活动记录空间大小＂ 域中有一个即可。

#### 什么信息不在过程活动记录中？

- 非局部数据
- 运行时生成的动态变量



### 过程活动记录的申请和释放

#### 调用链

##### 什么是调用链？

- 调用链是以主程序名M为首部的**过程名的序列**

- 更详细的：

  - 若`(M....R)`是调用链
  - 并且R中有S的调用
  - 那么`(M.....R,S)`是调用链

- 我们使用
  $$
  CallChain(S) = (M,...,R,S)
  $$
  来表示S的调用链，其中S是正在执行的过程体，`M...R`是已经执行但是被中断的过程

- 调用链并不是唯一的【动态的】



#### 动态链

##### 什么是动态链？

- 动态链是过程活动记录AR的序列，这个序列和调用链相对应。

- 用于恢复**调用者**的AR

- S的动态链形式化定义为
  $$
  DynamicChains(S) = [AR(M),...,AR(R),AR(S)]
  $$
  

![image-20201103170236418](https://i.loli.net/2020/11/03/WN7EaHcPfFrliAX.png)

#### 活动记录的空间的分配和释放

##### 分配的时候做了什么？

- 在翻译(CALL, f, true , t) 时， 需要做以下工作：
  • 将t (返回值应存放的变址） 的地址存放到返回值单元。
  • 把sp 的值放到动态链地址单元。
  • 填写过程层数信息。
  • 保存返回地址。
  • 保存变址访问环境（必要的情况下）。
  • 保存AR 长度size。
  • 改变sp 的值。
  • 转向f的入口地址。

##### 释放的时候做了什么？

- 恢复寄存器。
- 改变sp的值，sp = 动态链地址空间存的值。
- 转向返回地址对应的代码执行。





## 变量访问环境



### 声明链

- 声明链是以主程序名M为首的过程名序列

- 具体定义为：若`(M,.....P)`是声明链

- 若P中有过程Q的声明，那么`(M,..R,Q)`是Q的声明链

- $$
  DeclaChain(Q) = (M,...P,Q)
  $$

- 对于任一过程Q，它的声明链是**唯一**的，并且在Q中出现的变量，其声明一定在DeclaChain(Q)中



### 变量访问环境

##### 什么是活跃活动记录LAR(S)

- 一个过程S在动态链中可有多个AR, 其中， 只有最新的AR(S)是可访问的，称可访问的AR(S)是LAR(S)

##### 什么是变量访问环境

- Q的声明链【DeclaChain(Q)】中的每个过程的活跃活动记录构成的链称为Q的当前变最访问环境
  $$
  VarVisitEnv(LAR(Q) ) = [LAR(M), …, LAR(P), LAR(Q)]
  $$
  



##### 如何表示变量的存储单元地址？

- 若有一个变量X在过程Q中。

- 那么X的存储单元地址为

- $$
  addr(X) = <LAR(Q)> + Offset_X
  $$





##### 如何实现变量访问环境【VarVisitEnv(LAR(Q) )】

###### Display 表方法

- 其中有全局Display 表【不细说】和局部Display表

###### 静态链方法



### Display表方法

#### 局部Display表方法

##### 什么是Display表？

- 对于每个**AR**引入一个**指针数组**，称为Display表， 每进入一个过程，在为它建立的活动记录区中增加一段连续的单元，用于存放它的**Display表**。
- 假定进入过程的层数为**L**, 则它的Display表含有**L+ 1**个单元。这L+ 1个单元自顶向下每个单元依次存放着现行层(L层），直接外层(L-1层），…，直至最外层(0层，主程序层） 的**每一层过程**的最新**活动记录的起始地址**。‘
- 换句话来说，Display表是和层数相关的【毕竟每一层也只能有一个活跃的过程活动记录】
- Display表保存在过程活动记录中

![image-20201103173213821](https://i.loli.net/2020/11/03/eiAk4sCWlEFqt8V.png)

##### Display表的大小什么时候可以确定？

- 编译时候可以确定，因为过程的层数在编译时可确定

##### 非局部量的绝对地址可表示为？

- ```
  绝对地址=Display [静态层数］＋相对地址
  对一个变量X(L, off)，地址为：
当L= CurrentAR.level时：addr(X)=		sp+off
  否则:
  addr(X)=CurrentAR.Display[L]+ off：	   [sp+D+L]+off
  ```
  
- eg

- 假定现行过程中引用了某一外层过程（假定层数为L) 的变量x, 那么，可用下面两条变址指令获得x的值：

- ```
LOADR Rl,( lnitOff + L)[SP] / *获得第L层过程的最新活动记录地址*/
  LOADR R2, Offsetx [R1] / *把x的值传递给R2* /
  ```





##### Display表是如何建立的？

- 当过程P调用过程Q而进入Q后，Q如何建立其Display表【这里则使用到了动态链】

<img src="https://i.loli.net/2020/11/03/dl5fzHrgLhJRpI7.png" alt="image-20201103173549768" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/11/03/6e4HDgh12ovndFR.png" alt="image-20201103174028914" style="zoom:50%;" />

- 而对于层数的描述是指声明链的层数`level`



###### eg

- 假设有图9. 18 所示的Display 表示意图， 并且有Level(M) = 0, Level(Q) = 1, Level(R) =l, Level(S)= 2, 假设当前过程S 有变掀Xs、YQ 和ZM,其中，下标名表示变址被定义的过程名，若用Lx、Ly和Lz分别表示相应变址的层次，

- 则上述3个变址的地址分别如下：

- ```
  addr(Xs) = sp+offsetx
  addr(Yq) = (sp+InitOff)[Ly]+offsety
  addr(Zm) = (sp+InitOff)[Lz]+offsetz
  ```

#### 全局Display表法

- 略

### 静态链方法

#### 为什么要静态链方法？

- 节省空间

#### 什么是静态链指针？

- 是活动记录的一个域，指向**直接**外层过程【上一层】的最新活动记录的始地址
- 这些指针所构成的链式静态链

#### 如何填写静态链指针？

![image-20201103180249851](https://i.loli.net/2020/11/03/VA1qIdQ2XzaNnGx.png)



- ```
  当NewAr.Level > CurrentAR.Level 时，NewAR.Static = sp
  当NewAR.Level <= CurrentAR.Level 时，NewAR.Static = Indir(sp,m) ,其中m=CurrentAR.Level -NewAR.Level +1
  Indir(sp,m)表示sp的m次间接内容
  ```

  

#### 使用静态链指针的变量如何访问

```
变量X(L,off)的地址
若L = CurrentAR.Level，则addr(X) = sp+off
若L = CurrentAR.Level + 1 - k，则addr(X)=Indir(sp,k)+off
```



### 注意！

- 只有嵌套式语言才有变量访问环境的概念
- 并列式语言不需要变量访问环境

#### 指针sp

- 指向当前正在运行的过程的活动记录的基地址

#### 动态链

- 指向调用者的最新活动记录的基地址

#### 静态链指针

- 指向当前正在运行的过程的静态直接外层过程的基地址



## EG

![image-20201103181617651](https://i.loli.net/2020/11/03/l9zqFeTpKOfkc6W.png)





# 其他

## 当处理函数调用语句时，需要做哪些语义检查？

- 函数名是否为函数标识符
- 形参和实参类型是否相容
- 参数个数是否相等

## 编译器的构成及其各个部分的功能和作用？

- ![image-20201113221147295](https://i.loli.net/2020/11/13/DlAqfHUCjBvs5PJ.png)



## 符号表的偏移

- 常量生成目标代码的时候就已经被替换成值，所以就不需要写偏移量
- 静态和全局变量保存在静态区，需要计算偏移量



## LL1分析表

- 记得左递归！和公共前缀的消除！

## 语言的3个基本要素

- 语法，语义，语用

![image-20201202170530087](C:\Users\Xxgzbd\Desktop\image-20201202170530087.png)